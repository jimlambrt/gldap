
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>gldap: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/jimlambrt/gldap/add.go (100.0%)</option>
				
				<option value="file1">github.com/jimlambrt/gldap/conn.go (83.9%)</option>
				
				<option value="file2">github.com/jimlambrt/gldap/control.go (94.8%)</option>
				
				<option value="file3">github.com/jimlambrt/gldap/control_options.go (100.0%)</option>
				
				<option value="file4">github.com/jimlambrt/gldap/entry.go (100.0%)</option>
				
				<option value="file5">github.com/jimlambrt/gldap/message.go (80.0%)</option>
				
				<option value="file6">github.com/jimlambrt/gldap/message_options.go (81.2%)</option>
				
				<option value="file7">github.com/jimlambrt/gldap/modify.go (100.0%)</option>
				
				<option value="file8">github.com/jimlambrt/gldap/mux.go (91.7%)</option>
				
				<option value="file9">github.com/jimlambrt/gldap/option.go (100.0%)</option>
				
				<option value="file10">github.com/jimlambrt/gldap/packet.go (76.0%)</option>
				
				<option value="file11">github.com/jimlambrt/gldap/request.go (78.6%)</option>
				
				<option value="file12">github.com/jimlambrt/gldap/response.go (97.6%)</option>
				
				<option value="file13">github.com/jimlambrt/gldap/response_options.go (100.0%)</option>
				
				<option value="file14">github.com/jimlambrt/gldap/route.go (94.4%)</option>
				
				<option value="file15">github.com/jimlambrt/gldap/route_options.go (100.0%)</option>
				
				<option value="file16">github.com/jimlambrt/gldap/server.go (89.0%)</option>
				
				<option value="file17">github.com/jimlambrt/gldap/server_options.go (100.0%)</option>
				
				<option value="file18">github.com/jimlambrt/gldap/sid.go (76.7%)</option>
				
				<option value="file19">github.com/jimlambrt/gldap/testdirectory/directory.go (84.3%)</option>
				
				<option value="file20">github.com/jimlambrt/gldap/testdirectory/options.go (100.0%)</option>
				
				<option value="file21">github.com/jimlambrt/gldap/testdirectory/testing.go (100.0%)</option>
				
				<option value="file22">github.com/jimlambrt/gldap/testdirectory/testingt.go (100.0%)</option>
				
				<option value="file23">github.com/jimlambrt/gldap/testing.go (96.4%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package gldap

import (
        "fmt"

        ber "github.com/go-asn1-ber/asn1-ber"
)

// AddMessage is an add request message
type AddMessage struct {
        baseMessage
        // DN identifies the entry being added
        DN string
        // Attributes list the attributes of the new entry
        Attributes []Attribute
        // Controls hold optional controls to send with the request
        Controls []Control
}

// Attribute represents an LDAP attribute within AddMessage
type Attribute struct {
        // Type is the name of the LDAP attribute
        Type string
        // Vals are the LDAP attribute values
        Vals []string
}

func (a *Attribute) encode() *ber.Packet <span class="cov8" title="1">{
        seq := ber.Encode(ber.ClassUniversal, ber.TypeConstructed, ber.TagSequence, nil, "Attribute")
        seq.AppendChild(ber.NewString(ber.ClassUniversal, ber.TypePrimitive, ber.TagOctetString, a.Type, "Type"))
        set := ber.Encode(ber.ClassUniversal, ber.TypeConstructed, ber.TagSet, nil, "AttributeValue")
        for _, value := range a.Vals </span><span class="cov8" title="1">{
                set.AppendChild(ber.NewString(ber.ClassUniversal, ber.TypePrimitive, ber.TagOctetString, value, "Vals"))
        }</span>
        <span class="cov8" title="1">seq.AppendChild(set)
        return seq</span>
}

func decodeAttribute(berPacket *ber.Packet) (*Attribute, error) <span class="cov8" title="1">{
        const op = "gldap.decodeAttribute"
        const (
                childType     = 0
                childVals     = 1
                childControls = 2
        )
        if berPacket == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%s: missing ber packet: %w", op, ErrInvalidParameter)
        }</span>

        <span class="cov8" title="1">var decodedAttribute Attribute

        seq := &amp;packet{
                Packet: berPacket,
        }
        if err := seq.assert(ber.ClassUniversal, ber.TypeConstructed, withTag(ber.TagSequence)); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%s: missing/invalid attributes ber packet: %w", op, ErrInvalidParameter)
        }</span>
        <span class="cov8" title="1">if err := seq.assert(ber.ClassUniversal, ber.TypePrimitive, withTag(ber.TagOctetString), withAssertChild(childType)); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%s: missing/invalid attributes type: %w", op, ErrInvalidParameter)
        }</span>
        <span class="cov8" title="1">decodedAttribute.Type = seq.Children[childType].Data.String()

        if err := seq.assert(ber.ClassUniversal, ber.TypeConstructed, withTag(ber.TagSet), withAssertChild(childVals)); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%s: missing/invalid attributes values: %w", op, ErrInvalidParameter)
        }</span>
        <span class="cov8" title="1">valuesPacket := &amp;packet{
                Packet: seq.Children[childVals],
        }
        decodedAttribute.Vals = make([]string, 0, len(valuesPacket.Children))
        for idx := range valuesPacket.Children </span><span class="cov8" title="1">{
                if err := valuesPacket.assert(ber.ClassUniversal, ber.TypePrimitive, withTag(ber.TagOctetString), withAssertChild(idx)); err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("%s: invalid attribute values packet: %w", op, err)
                }</span>
                <span class="cov8" title="1">decodedAttribute.Vals = append(decodedAttribute.Vals, valuesPacket.Children[idx].Data.String())</span>
        }

        <span class="cov8" title="1">return &amp;decodedAttribute, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package gldap

import (
        "bufio"
        "context"
        "errors"
        "fmt"
        "io"
        "net"
        "strings"
        "sync"
        "time"

        ber "github.com/go-asn1-ber/asn1-ber"
        "github.com/hashicorp/go-hclog"
)

// conn is a connection to an ldap client
type conn struct {
        mu sync.Mutex // mutex for the conn

        connID      int
        netConn     net.Conn
        logger      hclog.Logger
        router      *Mux
        shutdownCtx context.Context
        requestsWg  sync.WaitGroup

        reader   *bufio.Reader
        writer   *bufio.Writer
        writerMu sync.Mutex // shared lock across all ResponseWriter's to prevent write data races
}

// newConn will create a new Conn from an accepted net.Conn which will be used
// to serve requests to an ldap client.
func newConn(shutdownCtx context.Context, connID int, netConn net.Conn, logger hclog.Logger, router *Mux) (*conn, error) <span class="cov8" title="1">{
        const op = "gldap.NewConn"
        if shutdownCtx == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%s: missing shutdown context: %w", op, ErrInvalidParameter)
        }</span>
        <span class="cov8" title="1">if connID == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%s: missing connection id: %w", op, ErrInvalidParameter)
        }</span>
        <span class="cov8" title="1">if netConn == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%s: missing connection: %w", op, ErrInvalidParameter)
        }</span>
        <span class="cov8" title="1">if logger == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%s: missing logger: %w", op, ErrInvalidParameter)
        }</span>
        <span class="cov8" title="1">if router == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%s: missing router: %w", op, ErrInvalidParameter)
        }</span>
        <span class="cov8" title="1">c := &amp;conn{
                connID:      connID,
                netConn:     netConn,
                shutdownCtx: shutdownCtx,
                logger:      logger,
                router:      router,
        }
        if err := c.initConn(netConn); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: %w", op, err)
        }</span>
        <span class="cov8" title="1">return c, nil</span>
}

// serveRequests until the connection is closed or the shutdownCtx is cancelled
// as the server stops
func (c *conn) serveRequests() error <span class="cov8" title="1">{
        const op = "gldap.serveRequests"

        requestID := 0
        for </span><span class="cov8" title="1">{
                requestID++
                w, err := newResponseWriter(c.writer, &amp;c.writerMu, c.logger, c.connID, requestID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("%s: %w", op, err)
                }</span>

                <span class="cov8" title="1">select </span>{
                case &lt;-c.shutdownCtx.Done():<span class="cov0" title="0">
                        c.logger.Debug("received shutdown cancellation", "op", op, "conn", c.connID, "requestID", w.requestID)
                        // build a request by hand, since this is not a normal situation
                        // where we've read a request... and we need to make this check
                        // before blocking on reading the next request.
                        req := &amp;Request{
                                ID:           w.requestID,
                                conn:         c,
                                message:      &amp;ExtendedOperationMessage{baseMessage: baseMessage{id: 0}},
                                routeOp:      routeOperation(ExtendedOperationDisconnection),
                                extendedName: ExtendedOperationDisconnection,
                        }
                        resp := req.NewResponse(WithResponseCode(ResultUnwillingToPerform), WithDiagnosticMessage("server stopping"))
                        if err := w.Write(resp); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("%s: %w", op, err)
                        }</span>
                        <span class="cov0" title="0">if err := c.netConn.SetReadDeadline(time.Now().Add(time.Millisecond)); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("%s: %w", op, err)
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                default:<span class="cov8" title="1"></span>
                        // need a default to fall through to rest of loop...
                }
                <span class="cov8" title="1">r, err := c.readRequest(w.requestID)
                if err != nil </span><span class="cov8" title="1">{
                        if errors.Is(err, io.EOF) || errors.Is(err, io.ErrUnexpectedEOF) || strings.Contains(err.Error(), "unexpected EOF") </span><span class="cov8" title="1">{
                                return nil // connection is closed
                        }</span>
                        <span class="cov8" title="1">return fmt.Errorf("%s: error reading request: %w", op, err)</span>
                }

                <span class="cov8" title="1">switch </span>{
                // TODO: rate limit in-flight requests per conn and send a
                // BusyResponse when the limit is reached.  This limit per conn
                // should be configurable

                case r.routeOp == unbindRouteOperation:<span class="cov8" title="1">
                        // support an optional unbind route
                        if c.router.unbindRoute != nil </span><span class="cov8" title="1">{
                                c.router.unbindRoute.handler()(w, r)
                        }</span>
                        // stop serving requests when UnbindRequest is received
                        <span class="cov8" title="1">return nil</span>

                // If it's a StartTLS request, then we can't dispatch it concurrently,
                // since the conn needs to complete it's TLS negotiation before handling
                // any other requests.
                // see: https://datatracker.ietf.org/doc/html/rfc4511#section-4.14.1
                case r.extendedName == ExtendedOperationStartTLS:<span class="cov8" title="1">
                        c.router.serve(w, r)</span>
                default:<span class="cov8" title="1">
                        c.requestsWg.Add(1)
                        go func() </span><span class="cov8" title="1">{
                                defer func() </span><span class="cov8" title="1">{
                                        c.logger.Debug("requestsWg done", "op", op, "conn", c.connID, "requestID", w.requestID)
                                        c.requestsWg.Done()
                                }</span>()
                                <span class="cov8" title="1">c.router.serve(w, r)</span>
                        }()
                }
        }
}

func (c *conn) readRequest(requestID int) (*Request, error) <span class="cov8" title="1">{
        const op = "gldap.(Conn).readRequest"

        p, err := c.readPacket(requestID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%s: error reading packet for %d/%d: %w", op, c.connID, requestID, err)
        }</span>
        <span class="cov8" title="1">r, err := newRequest(requestID, c, p)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: unable to create new in-memory request for %d/%d: %w", op, c.connID, requestID, err)
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}

func (c *conn) readPacket(requestID int) (*packet, error) <span class="cov8" title="1">{
        const op = "gldap.readPacket"
        // read a request
        berPacket, err := func() (*ber.Packet, error) </span><span class="cov8" title="1">{
                c.mu.Lock()
                defer c.mu.Unlock()
                berPacket, err := ber.ReadPacket(c.reader)
                switch </span>{
                case err != nil &amp;&amp; strings.Contains(err.Error(), "invalid character for IA5String at pos 2"):<span class="cov0" title="0">
                        return nil, fmt.Errorf("%s: error reading ber packet for %d/%d (possible attempt to use TLS with a non-TLS server): %w", op, c.connID, requestID, err)</span>
                case err != nil:<span class="cov8" title="1">
                        return nil, fmt.Errorf("%s: error reading ber packet for %d/%d: %w", op, c.connID, requestID, err)</span>
                }
                <span class="cov8" title="1">return berPacket, nil</span>
        }()
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">p := &amp;packet{Packet: berPacket}
        if c.logger.IsDebug() </span><span class="cov8" title="1">{
                c.logger.Debug("packet read", "op", op, "conn", c.connID, "requestID", requestID)
                p.Log(c.logger.StandardWriter(&amp;hclog.StandardLoggerOptions{}), 0, false)
        }</span>
        // Simple header is first... let's make sure it's an ldap packet with 2
        // children containing:
        //                [0] is a message ID
        //                [1] is a request header
        <span class="cov8" title="1">if err := p.basicValidation(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: failed validation: %w", op, err)
        }</span>
        <span class="cov8" title="1">return p, nil</span>
}

func (c *conn) initConn(netConn net.Conn) error <span class="cov8" title="1">{
        const op = "gldap.(Conn).initConn"
        if netConn == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%s: missing net conn: %w", op, ErrInvalidParameter)
        }</span>
        <span class="cov8" title="1">c.mu.Lock()
        defer c.mu.Unlock()
        c.netConn = netConn
        c.reader = bufio.NewReader(c.netConn)
        c.writer = bufio.NewWriter(c.netConn)
        return nil</span>
}

func (c *conn) close() error <span class="cov8" title="1">{
        const op = "gldap.(Conn).close"
        c.requestsWg.Wait()
        if err := c.netConn.Close(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: error closing conn: %w", op, err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package gldap

import (
        "fmt"
        "strconv"

        ber "github.com/go-asn1-ber/asn1-ber"
)

const (
        // ControlTypePaging - https://www.ietf.org/rfc/rfc2696.txt
        ControlTypePaging = "1.2.840.113556.1.4.319"
        // ControlTypeBeheraPasswordPolicy - https://tools.ietf.org/html/draft-behera-ldap-password-policy-10
        ControlTypeBeheraPasswordPolicy = "1.3.6.1.4.1.42.2.27.8.5.1"
        // ControlTypeVChuPasswordMustChange - https://tools.ietf.org/html/draft-vchu-ldap-pwd-policy-00
        ControlTypeVChuPasswordMustChange = "2.16.840.1.113730.3.4.4"
        // ControlTypeVChuPasswordWarning - https://tools.ietf.org/html/draft-vchu-ldap-pwd-policy-00
        ControlTypeVChuPasswordWarning = "2.16.840.1.113730.3.4.5"
        // ControlTypeManageDsaIT - https://tools.ietf.org/html/rfc3296
        ControlTypeManageDsaIT = "2.16.840.1.113730.3.4.2"
        // ControlTypeWhoAmI - https://tools.ietf.org/html/rfc4532
        ControlTypeWhoAmI = "1.3.6.1.4.1.4203.1.11.3"

        // ControlTypeMicrosoftNotification - https://msdn.microsoft.com/en-us/library/aa366983(v=vs.85).aspx
        ControlTypeMicrosoftNotification = "1.2.840.113556.1.4.528"
        // ControlTypeMicrosoftShowDeleted - https://msdn.microsoft.com/en-us/library/aa366989(v=vs.85).aspx
        ControlTypeMicrosoftShowDeleted = "1.2.840.113556.1.4.417"
        // ControlTypeMicrosoftServerLinkTTL - https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-adts/f4f523a8-abc0-4b3a-a471-6b2fef135481?redirectedfrom=MSDN
        ControlTypeMicrosoftServerLinkTTL = "1.2.840.113556.1.4.2309"
)

// ControlTypeMap maps controls to text descriptions
var ControlTypeMap = map[string]string{
        ControlTypePaging:                 "Paging",
        ControlTypeBeheraPasswordPolicy:   "Password Policy - Behera Draft",
        ControlTypeManageDsaIT:            "Manage DSA IT",
        ControlTypeMicrosoftNotification:  "Change Notification - Microsoft",
        ControlTypeMicrosoftShowDeleted:   "Show Deleted Objects - Microsoft",
        ControlTypeMicrosoftServerLinkTTL: "Return TTL-DNs for link values with associated expiry times - Microsoft",
}

// Ldap Behera Password Policy Draft 10 (https://tools.ietf.org/html/draft-behera-ldap-password-policy-10)
const (
        BeheraPasswordExpired             = 0
        BeheraAccountLocked               = 1
        BeheraChangeAfterReset            = 2
        BeheraPasswordModNotAllowed       = 3
        BeheraMustSupplyOldPassword       = 4
        BeheraInsufficientPasswordQuality = 5
        BeheraPasswordTooShort            = 6
        BeheraPasswordTooYoung            = 7
        BeheraPasswordInHistory           = 8
)

// BeheraPasswordPolicyErrorMap contains human readable descriptions of Behera Password Policy error codes
var BeheraPasswordPolicyErrorMap = map[int8]string{
        BeheraPasswordExpired:             "Password expired",
        BeheraAccountLocked:               "Account locked",
        BeheraChangeAfterReset:            "Password must be changed",
        BeheraPasswordModNotAllowed:       "Policy prevents password modification",
        BeheraMustSupplyOldPassword:       "Policy requires old password in order to change password",
        BeheraInsufficientPasswordQuality: "Password fails quality checks",
        BeheraPasswordTooShort:            "Password is too short for policy",
        BeheraPasswordTooYoung:            "Password has been changed too recently",
        BeheraPasswordInHistory:           "New password is in list of old passwords",
}

// Control defines a common interface for all ldap controls
type Control interface {
        // GetControlType returns the OID
        GetControlType() string
        // Encode returns the ber packet representation
        Encode() *ber.Packet
        // String returns a human-readable description
        String() string
}

func encodeControls(controls []Control) *ber.Packet <span class="cov8" title="1">{
        packet := ber.Encode(ber.ClassContext, ber.TypeConstructed, 0, nil, "Controls")
        for _, control := range controls </span><span class="cov8" title="1">{
                packet.AppendChild(control.Encode())
        }</span>
        <span class="cov8" title="1">return packet</span>
}

func decodeControl(packet *ber.Packet) (Control, error) <span class="cov8" title="1">{
        const op = "gldap.decodeControl"
        var (
                ControlType = ""
                Criticality = false
                value       *ber.Packet
        )
        if packet == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%s: packet is nil: %w", op, ErrInvalidParameter)
        }</span>

        <span class="cov8" title="1">switch len(packet.Children) </span>{
        case 0:<span class="cov8" title="1">
                // at least one child is required for a control type
                return nil, fmt.Errorf("%s: at least one child is required for control type", op)</span>
        case 1:<span class="cov8" title="1">
                // just type, no critically or value
                packet.Children[0].Description = "Control Type (" + ControlTypeMap[ControlType] + ")"
                ControlType = packet.Children[0].Value.(string)</span>
        case 2:<span class="cov8" title="1">
                packet.Children[0].Description = "Control Type (" + ControlTypeMap[ControlType] + ")"
                ControlType = packet.Children[0].Value.(string)

                // Children[1] could be criticality or value (both are optional)
                // duck-type on whether this is a boolean
                if _, ok := packet.Children[1].Value.(bool); ok </span><span class="cov8" title="1">{
                        packet.Children[1].Description = "Criticality"
                        Criticality = packet.Children[1].Value.(bool)
                }</span> else<span class="cov8" title="1"> {
                        packet.Children[1].Description = "Control Value"
                        value = packet.Children[1]
                }</span>
        case 3:<span class="cov8" title="1">
                packet.Children[0].Description = "Control Type (" + ControlTypeMap[ControlType] + ")"
                ControlType = packet.Children[0].Value.(string)

                packet.Children[1].Description = "Criticality"
                Criticality = packet.Children[1].Value.(bool)

                packet.Children[2].Description = "Control Value"
                value = packet.Children[2]</span>
        default:<span class="cov8" title="1">
                // more than 3 children is invalid
                return nil, fmt.Errorf("%s: more than 3 children is invalid for controls", op)</span>
        }
        <span class="cov8" title="1">switch ControlType </span>{
        case ControlTypeManageDsaIT:<span class="cov8" title="1">
                return NewControlManageDsaIT(WithCriticality(Criticality))</span>
        case ControlTypePaging:<span class="cov8" title="1">
                if value == nil </span><span class="cov8" title="1">{
                        return new(ControlPaging), nil
                }</span>
                <span class="cov8" title="1">value.Description += " (Paging)"
                c := new(ControlPaging)
                if value.Value != nil </span><span class="cov8" title="1">{
                        valueChildren, err := ber.DecodePacketErr(value.Data.Bytes())
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("%s, failed to decode data bytes: %w", op, err)
                        }</span>
                        <span class="cov8" title="1">value.Data.Truncate(0)
                        value.Value = nil
                        value.AppendChild(valueChildren)</span>
                }
                <span class="cov8" title="1">if len(value.Children) &lt; 1 </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("%s: paging control value must have a least 1 child: %w", op, ErrInvalidParameter)
                }</span>
                <span class="cov8" title="1">value = value.Children[0]
                value.Description = "Search Control Value"
                value.Children[0].Description = "Paging Size"
                value.Children[1].Description = "Cookie"
                c.PagingSize = uint32(value.Children[0].Value.(int64))
                c.Cookie = value.Children[1].Data.Bytes()
                value.Children[1].Value = c.Cookie
                return c, nil</span>
        case ControlTypeBeheraPasswordPolicy:<span class="cov8" title="1">
                if value == nil </span><span class="cov8" title="1">{
                        c, err := NewControlBeheraPasswordPolicy()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("%s: %w", op, err)
                        }</span>
                        <span class="cov8" title="1">return c, nil</span>
                }
                <span class="cov8" title="1">value.Description += " (Password Policy - Behera)"
                c, err := NewControlBeheraPasswordPolicy()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%s: failed to create behera password control", op)
                }</span>
                <span class="cov8" title="1">if value.Value != nil </span><span class="cov8" title="1">{
                        valueChildren, err := ber.DecodePacketErr(value.Data.Bytes())
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("%s: failed to decode data bytes: %w", op, err)
                        }</span>
                        <span class="cov8" title="1">value.Data.Truncate(0)
                        value.Value = nil
                        value.AppendChild(valueChildren)</span>
                }
                <span class="cov8" title="1">if len(value.Children) == 0 </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("%s: behera control value must have a least 1 child: %w", op, ErrInvalidParameter)
                }</span>

                <span class="cov8" title="1">sequence := value.Children[0]

                for _, child := range sequence.Children </span><span class="cov8" title="1">{
                        if child.Tag == 0 </span><span class="cov8" title="1">{
                                // Warning
                                warningPacket := child.Children[0]
                                val, err := ber.ParseInt64(warningPacket.Data.Bytes())
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("%s: failed to decode data bytes: %w", op, err)
                                }</span>
                                <span class="cov8" title="1">if warningPacket.Tag == 0 </span><span class="cov8" title="1">{
                                        // timeBeforeExpiration
                                        c.expire = val
                                        warningPacket.Value = c.expire
                                }</span> else<span class="cov8" title="1"> if warningPacket.Tag == 1 </span><span class="cov8" title="1">{
                                        // graceAuthNsRemaining
                                        c.grace = val
                                        warningPacket.Value = c.grace
                                }</span>
                        } else<span class="cov8" title="1"> if child.Tag == 1 </span><span class="cov8" title="1">{
                                // Error
                                bs := child.Data.Bytes()
                                if len(bs) != 1 || bs[0] &gt; 8 </span><span class="cov8" title="1">{
                                        return nil, fmt.Errorf("%s: failed to decode data bytes: %s", "invalid PasswordPolicyResponse enum value", op)
                                }</span>
                                <span class="cov8" title="1">val := int8(bs[0])
                                c.error = val
                                child.Value = c.error
                                c.errorString = BeheraPasswordPolicyErrorMap[c.error]</span>
                        }
                }
                <span class="cov8" title="1">return c, nil</span>
        case ControlTypeVChuPasswordMustChange:<span class="cov8" title="1">
                c := &amp;ControlVChuPasswordMustChange{MustChange: true}
                return c, nil</span>
        case ControlTypeVChuPasswordWarning:<span class="cov8" title="1">
                if value == nil </span><span class="cov8" title="1">{
                        return &amp;ControlVChuPasswordWarning{Expire: -1}, nil
                }</span>
                <span class="cov8" title="1">c := &amp;ControlVChuPasswordWarning{Expire: -1}
                expireStr := ber.DecodeString(value.Data.Bytes())

                expire, err := strconv.ParseInt(expireStr, 10, 64)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("%s: failed to parse value as int: %w", op, err)
                }</span>
                <span class="cov8" title="1">c.Expire = expire
                value.Value = c.Expire
                return c, nil</span>
        case ControlTypeMicrosoftNotification:<span class="cov8" title="1">
                return NewControlMicrosoftNotification()</span>
        case ControlTypeMicrosoftShowDeleted:<span class="cov8" title="1">
                return NewControlMicrosoftShowDeleted()</span>
        case ControlTypeMicrosoftServerLinkTTL:<span class="cov8" title="1">
                return NewControlMicrosoftServerLinkTTL()</span>
        default:<span class="cov8" title="1">
                c := new(ControlString)
                c.ControlType = ControlType
                c.Criticality = Criticality
                if value != nil </span><span class="cov8" title="1">{
                        c.ControlValue = value.Value.(string)
                }</span>
                <span class="cov8" title="1">return c, nil</span>
        }
}

// ControlString implements the Control interface for simple controls
type ControlString struct {
        ControlType  string
        Criticality  bool
        ControlValue string
}

// GetControlType returns the OID
func (c *ControlString) GetControlType() string <span class="cov8" title="1">{
        return c.ControlType
}</span>

// Encode returns the ber packet representation
func (c *ControlString) Encode() *ber.Packet <span class="cov8" title="1">{
        packet := ber.Encode(ber.ClassUniversal, ber.TypeConstructed, ber.TagSequence, nil, "Control")
        packet.AppendChild(ber.NewString(ber.ClassUniversal, ber.TypePrimitive, ber.TagOctetString, c.ControlType, "Control Type ("+ControlTypeMap[c.ControlType]+")"))
        if c.Criticality </span><span class="cov8" title="1">{
                packet.AppendChild(ber.NewBoolean(ber.ClassUniversal, ber.TypePrimitive, ber.TagBoolean, c.Criticality, "Criticality"))
        }</span>
        <span class="cov8" title="1">if c.ControlValue != "" </span><span class="cov8" title="1">{
                packet.AppendChild(ber.NewString(ber.ClassUniversal, ber.TypePrimitive, ber.TagOctetString, string(c.ControlValue), "Control Value"))
        }</span>
        <span class="cov8" title="1">return packet</span>
}

// String returns a human-readable description
func (c *ControlString) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("Control Type: %s (%q)  Criticality: %t  Control Value: %s", ControlTypeMap[c.ControlType], c.ControlType, c.Criticality, c.ControlValue)
}</span>

// NewControlString returns a generic control.  Options supported:
// WithCriticality and WithControlValue
func NewControlString(controlType string, opt ...Option) (*ControlString, error) <span class="cov8" title="1">{
        const op = "gldap.NewControlString"
        if controlType == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%s: missing control type: %w", op, ErrInvalidParameter)
        }</span>
        <span class="cov8" title="1">opts := getControlOpts(opt...)
        return &amp;ControlString{
                ControlType:  controlType,
                Criticality:  opts.withCriticality,
                ControlValue: opts.withControlValue,
        }, nil</span>
}

// ControlManageDsaIT implements the control described in https://tools.ietf.org/html/rfc3296
type ControlManageDsaIT struct {
        // Criticality indicates if this control is required
        Criticality bool
}

// Encode returns the ber packet representation
func (c *ControlManageDsaIT) Encode() *ber.Packet <span class="cov8" title="1">{
        // FIXME
        packet := ber.Encode(ber.ClassUniversal, ber.TypeConstructed, ber.TagSequence, nil, "Control")
        packet.AppendChild(ber.NewString(ber.ClassUniversal, ber.TypePrimitive, ber.TagOctetString, ControlTypeManageDsaIT, "Control Type ("+ControlTypeMap[ControlTypeManageDsaIT]+")"))
        if c.Criticality </span><span class="cov8" title="1">{
                packet.AppendChild(ber.NewBoolean(ber.ClassUniversal, ber.TypePrimitive, ber.TagBoolean, c.Criticality, "Criticality"))
        }</span>
        <span class="cov8" title="1">return packet</span>
}

// GetControlType returns the OID
func (c *ControlManageDsaIT) GetControlType() string <span class="cov8" title="1">{
        return ControlTypeManageDsaIT
}</span>

// String returns a human-readable description
func (c *ControlManageDsaIT) String() string <span class="cov8" title="1">{
        return fmt.Sprintf(
                "Control Type: %s (%q)  Criticality: %t",
                ControlTypeMap[ControlTypeManageDsaIT],
                ControlTypeManageDsaIT,
                c.Criticality)
}</span>

// NewControlManageDsaIT returns a ControlManageDsaIT control.  Supported
// options: WithCriticality
func NewControlManageDsaIT(opt ...Option) (*ControlManageDsaIT, error) <span class="cov8" title="1">{
        opts := getControlOpts(opt...)
        return &amp;ControlManageDsaIT{Criticality: opts.withCriticality}, nil
}</span>

// ControlMicrosoftNotification implements the control described in https://msdn.microsoft.com/en-us/library/aa366983(v=vs.85).aspx
type ControlMicrosoftNotification struct{}

// GetControlType returns the OID
func (c *ControlMicrosoftNotification) GetControlType() string <span class="cov8" title="1">{
        return ControlTypeMicrosoftNotification
}</span>

// Encode returns the ber packet representation
func (c *ControlMicrosoftNotification) Encode() *ber.Packet <span class="cov8" title="1">{
        packet := ber.Encode(ber.ClassUniversal, ber.TypeConstructed, ber.TagSequence, nil, "Control")
        packet.AppendChild(ber.NewString(ber.ClassUniversal, ber.TypePrimitive, ber.TagOctetString, ControlTypeMicrosoftNotification, "Control Type ("+ControlTypeMap[ControlTypeMicrosoftNotification]+")"))

        return packet
}</span>

// String returns a human-readable description
func (c *ControlMicrosoftNotification) String() string <span class="cov8" title="1">{
        return fmt.Sprintf(
                "Control Type: %s (%q)",
                ControlTypeMap[ControlTypeMicrosoftNotification],
                ControlTypeMicrosoftNotification)
}</span>

// NewControlMicrosoftNotification returns a ControlMicrosoftNotification
// control.  No options are currently supported.
func NewControlMicrosoftNotification(_ ...Option) (*ControlMicrosoftNotification, error) <span class="cov8" title="1">{
        return &amp;ControlMicrosoftNotification{}, nil
}</span>

// ControlMicrosoftServerLinkTTL implements the control described in https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-adts/f4f523a8-abc0-4b3a-a471-6b2fef135481?redirectedfrom=MSDN
type ControlMicrosoftServerLinkTTL struct{}

// GetControlType returns the OID
func (c *ControlMicrosoftServerLinkTTL) GetControlType() string <span class="cov8" title="1">{
        return ControlTypeMicrosoftServerLinkTTL
}</span>

// Encode returns the ber packet representation
func (c *ControlMicrosoftServerLinkTTL) Encode() *ber.Packet <span class="cov8" title="1">{
        packet := ber.Encode(ber.ClassUniversal, ber.TypeConstructed, ber.TagSequence, nil, "Control")
        packet.AppendChild(ber.NewString(ber.ClassUniversal, ber.TypePrimitive, ber.TagOctetString, ControlTypeMicrosoftServerLinkTTL, "Control Type ("+ControlTypeMap[ControlTypeMicrosoftServerLinkTTL]+")"))

        return packet
}</span>

// String returns a human-readable description
func (c *ControlMicrosoftServerLinkTTL) String() string <span class="cov8" title="1">{
        return fmt.Sprintf(
                "Control Type: %s (%q)",
                ControlTypeMap[ControlTypeMicrosoftServerLinkTTL],
                ControlTypeMicrosoftServerLinkTTL)
}</span>

// NewControlMicrosoftServerLinkTTL returns a ControlMicrosoftServerLinkTTL
// control.  No options are currently supported.
func NewControlMicrosoftServerLinkTTL(_ ...Option) (*ControlMicrosoftServerLinkTTL, error) <span class="cov8" title="1">{
        return &amp;ControlMicrosoftServerLinkTTL{}, nil
}</span>

// ControlMicrosoftShowDeleted implements the control described in https://msdn.microsoft.com/en-us/library/aa366989(v=vs.85).aspx
type ControlMicrosoftShowDeleted struct{}

// GetControlType returns the OID
func (c *ControlMicrosoftShowDeleted) GetControlType() string <span class="cov8" title="1">{
        return ControlTypeMicrosoftShowDeleted
}</span>

// Encode returns the ber packet representation
func (c *ControlMicrosoftShowDeleted) Encode() *ber.Packet <span class="cov8" title="1">{
        packet := ber.Encode(ber.ClassUniversal, ber.TypeConstructed, ber.TagSequence, nil, "Control")
        packet.AppendChild(ber.NewString(ber.ClassUniversal, ber.TypePrimitive, ber.TagOctetString, ControlTypeMicrosoftShowDeleted, "Control Type ("+ControlTypeMap[ControlTypeMicrosoftShowDeleted]+")"))

        return packet
}</span>

// String returns a human-readable description
func (c *ControlMicrosoftShowDeleted) String() string <span class="cov8" title="1">{
        return fmt.Sprintf(
                "Control Type: %s (%q)",
                ControlTypeMap[ControlTypeMicrosoftShowDeleted],
                ControlTypeMicrosoftShowDeleted)
}</span>

// NewControlMicrosoftShowDeleted returns a ControlMicrosoftShowDeleted control.
// No options are currently supported.
func NewControlMicrosoftShowDeleted(_ ...Option) (*ControlMicrosoftShowDeleted, error) <span class="cov8" title="1">{
        return &amp;ControlMicrosoftShowDeleted{}, nil
}</span>

// ControlBeheraPasswordPolicy implements the control described in https://tools.ietf.org/html/draft-behera-ldap-password-policy-10
type ControlBeheraPasswordPolicy struct {
        // expire contains the number of seconds before a password will expire
        expire int64
        // grace indicates the remaining number of times a user will be allowed to authenticate with an expired password
        grace int64
        // error indicates the error code
        error int8
        // errorString is a human readable error
        errorString string
}

// Grace returns the remaining number of times a user will be allowed to
// authenticate with an expired password. A value of -1 indicates it hasn't been
// set.
func (c *ControlBeheraPasswordPolicy) Grace() int <span class="cov8" title="1">{
        return int(c.grace)
}</span>

// Expire contains the number of seconds before a password will expire. A value
// of -1 indicates it hasn't been set.
func (c *ControlBeheraPasswordPolicy) Expire() int <span class="cov8" title="1">{
        return int(c.expire)
}</span>

// ErrorCode is the error code and a human readable string.  A value of -1 and
// empty string indicates it hasn't been set.
func (c *ControlBeheraPasswordPolicy) ErrorCode() (int, string) <span class="cov8" title="1">{
        return int(c.error), c.errorString
}</span>

// GetControlType returns the OID
func (c *ControlBeheraPasswordPolicy) GetControlType() string <span class="cov8" title="1">{
        return ControlTypeBeheraPasswordPolicy
}</span>

// Encode returns the ber packet representation
func (c *ControlBeheraPasswordPolicy) Encode() *ber.Packet <span class="cov8" title="1">{
        packet := ber.Encode(ber.ClassUniversal, ber.TypeConstructed, ber.TagSequence, nil, "Control")
        packet.AppendChild(ber.NewString(ber.ClassUniversal, ber.TypePrimitive, ber.TagOctetString, ControlTypeBeheraPasswordPolicy, "Control Type ("+ControlTypeMap[ControlTypeBeheraPasswordPolicy]+")"))

        switch </span>{
        case c.grace &gt;= 0:<span class="cov8" title="1">
                // control value packet for GraceAuthNsRemaining
                valuePacket := ber.Encode(ber.ClassUniversal, ber.TypePrimitive, ber.TagOctetString, nil, "")
                sequencePacket := ber.Encode(ber.ClassUniversal, ber.TypeConstructed, ber.TagSequence, nil, "")

                // it's a warning. so it's the end of a context (ber.TagEOC)
                contextPacket := ber.Encode(ber.ClassContext, ber.TypeConstructed, 0x00, nil, "")
                // "0x01" tag indicates an grace logins
                contextPacket.AppendChild(ber.NewInteger(ber.ClassContext, ber.TypePrimitive, 0x01, c.grace, ""))
                sequencePacket.AppendChild(contextPacket)

                valuePacket.AppendChild(sequencePacket)
                packet.AppendChild(valuePacket)
                return packet</span> // I believe you can only have either Grace or Expire for a response.... not both.
        case c.expire &gt;= 0:<span class="cov8" title="1">
                // control value packet for timeBeforeExpiration
                valuePacket := ber.Encode(ber.ClassUniversal, ber.TypePrimitive, ber.TagOctetString, nil, "")
                sequencePacket := ber.Encode(ber.ClassUniversal, ber.TypeConstructed, ber.TagSequence, nil, "")

                // it's a warning. so it's the end of a context (ber.TagEOC)
                contextPacket := ber.Encode(ber.ClassContext, ber.TypeConstructed, 0x00, nil, "")
                // "0x00" tag indicates an expires in
                contextPacket.AppendChild(ber.NewInteger(ber.ClassContext, ber.TypePrimitive, 0x00, c.expire, ""))
                sequencePacket.AppendChild(contextPacket)

                valuePacket.AppendChild(sequencePacket)
                packet.AppendChild(valuePacket)
                return packet</span> // I believe you can only have either Grace or Expire for a response.... not both.
        case c.error &gt;= 0:<span class="cov8" title="1">
                valuePacket := ber.Encode(ber.ClassUniversal, ber.TypePrimitive, ber.TagOctetString, nil, "")
                sequencePacket := ber.Encode(ber.ClassUniversal, ber.TypeConstructed, ber.TagSequence, nil, "")

                contextPacket := ber.NewInteger(ber.ClassContext, ber.TypePrimitive, 0x01, c.error, "")
                sequencePacket.AppendChild(contextPacket)

                valuePacket.AppendChild(sequencePacket)
                packet.AppendChild(valuePacket)</span>

        }
        <span class="cov8" title="1">return packet</span>
}

// String returns a human-readable description
func (c *ControlBeheraPasswordPolicy) String() string <span class="cov8" title="1">{
        return fmt.Sprintf(
                "Control Type: %s (%q)  Criticality: %t  Expire: %d  Grace: %d  Error: %d, ErrorString: %s",
                ControlTypeMap[ControlTypeBeheraPasswordPolicy],
                ControlTypeBeheraPasswordPolicy,
                false,
                c.expire,
                c.grace,
                c.error,
                c.errorString)
}</span>

// NewControlBeheraPasswordPolicy returns a ControlBeheraPasswordPolicy.
// Options supported: WithExpire, WithGrace, WithErrorCode
func NewControlBeheraPasswordPolicy(opt ...Option) (*ControlBeheraPasswordPolicy, error) <span class="cov8" title="1">{
        const op = "NewControlBeheraPolicy"
        opts := getControlOpts(opt...)
        switch </span>{
        case opts.withGrace != -1 &amp;&amp; opts.withExpire != -1:<span class="cov8" title="1">
                return nil, fmt.Errorf("%s: behera policies cannot have both grace and expire set: %w", op, ErrInvalidParameter)</span>
        case opts.withGrace != -1 &amp;&amp; opts.withErrorCode != -1:<span class="cov8" title="1">
                return nil, fmt.Errorf("%s: behera policies cannot have both grace and error codes set: %w", op, ErrInvalidParameter)</span>
        case opts.withExpire != -1 &amp;&amp; opts.withErrorCode != -1:<span class="cov8" title="1">
                return nil, fmt.Errorf("%s: behera polices cannot have both expire and error codes set: %w", op, ErrInvalidParameter)</span>
        case opts.withErrorCode &gt; 8:<span class="cov8" title="1">
                return nil, fmt.Errorf("%s: %d is not a valid behera policy error code (must be between 0-8: %w", op, opts.withErrorCode, ErrInvalidParameter)</span>
        }
        <span class="cov8" title="1">c := &amp;ControlBeheraPasswordPolicy{
                expire: int64(opts.withExpire),
                grace:  int64(opts.withGrace),
                error:  int8(opts.withErrorCode),
        }
        if opts.withErrorCode != -1 </span><span class="cov8" title="1">{
                c.errorString = BeheraPasswordPolicyErrorMap[int8(opts.withErrorCode)]
        }</span>
        <span class="cov8" title="1">return c, nil</span>
}

// ControlVChuPasswordMustChange implements the control described in https://tools.ietf.org/html/draft-vchu-ldap-pwd-policy-00
type ControlVChuPasswordMustChange struct {
        // MustChange indicates if the password is required to be changed
        MustChange bool
}

// GetControlType returns the OID
func (c *ControlVChuPasswordMustChange) GetControlType() string <span class="cov8" title="1">{
        return ControlTypeVChuPasswordMustChange
}</span>

// Encode returns the ber packet representation
func (c *ControlVChuPasswordMustChange) Encode() *ber.Packet <span class="cov8" title="1">{
        packet := ber.Encode(ber.ClassUniversal, ber.TypeConstructed, ber.TagSequence, nil, "Control")
        // I believe, just the control type child is require... not criticality or
        // value is require...
        packet.AppendChild(ber.NewString(ber.ClassUniversal, ber.TypePrimitive, ber.TagOctetString, ControlTypeVChuPasswordMustChange, "Control Type ("+ControlTypeMap[ControlTypeVChuPasswordMustChange]+")"))
        return packet
}</span>

// String returns a human-readable description
func (c *ControlVChuPasswordMustChange) String() string <span class="cov8" title="1">{
        return fmt.Sprintf(
                "Control Type: %s (%q)  Criticality: %t  MustChange: %v",
                ControlTypeMap[ControlTypeVChuPasswordMustChange],
                ControlTypeVChuPasswordMustChange,
                false,
                c.MustChange)
}</span>

// ControlVChuPasswordWarning implements the control described in https://tools.ietf.org/html/draft-vchu-ldap-pwd-policy-00
type ControlVChuPasswordWarning struct {
        // Expire indicates the time in seconds until the password expires
        Expire int64
}

// GetControlType returns the OID
func (c *ControlVChuPasswordWarning) GetControlType() string <span class="cov8" title="1">{
        return ControlTypeVChuPasswordWarning
}</span>

// Encode returns the ber packet representation
func (c *ControlVChuPasswordWarning) Encode() *ber.Packet <span class="cov8" title="1">{
        packet := ber.Encode(ber.ClassUniversal, ber.TypeConstructed, ber.TagSequence, nil, "Control")
        packet.AppendChild(ber.NewString(ber.ClassUniversal, ber.TypePrimitive, ber.TagOctetString, ControlTypeVChuPasswordWarning, "Control Type ("+ControlTypeMap[ControlTypeVChuPasswordWarning]+")"))
        // I believe, it's a string in the spec
        expStr := strconv.FormatInt(c.Expire, 10)
        packet.AppendChild(ber.NewString(ber.ClassUniversal, ber.TypePrimitive, ber.TagOctetString, expStr, "Control Value"))
        return packet
}</span>

// String returns a human-readable description
func (c *ControlVChuPasswordWarning) String() string <span class="cov8" title="1">{
        return fmt.Sprintf(
                "Control Type: %s (%q)  Criticality: %t  Expire: %d",
                ControlTypeMap[ControlTypeVChuPasswordWarning],
                ControlTypeVChuPasswordWarning,
                false,
                c.Expire)
}</span>

// ControlPaging implements the paging control described in https://www.ietf.org/rfc/rfc2696.txt
type ControlPaging struct {
        // PagingSize indicates the page size
        PagingSize uint32
        // Cookie is an opaque value returned by the server to track a paging cursor
        Cookie []byte
}

// GetControlType returns the OID
func (c *ControlPaging) GetControlType() string <span class="cov8" title="1">{
        return ControlTypePaging
}</span>

// Encode returns the ber packet representation
func (c *ControlPaging) Encode() *ber.Packet <span class="cov8" title="1">{
        packet := ber.Encode(ber.ClassUniversal, ber.TypeConstructed, ber.TagSequence, nil, "Control")
        packet.AppendChild(ber.NewString(ber.ClassUniversal, ber.TypePrimitive, ber.TagOctetString, ControlTypePaging, "Control Type ("+ControlTypeMap[ControlTypePaging]+")"))

        p2 := ber.Encode(ber.ClassUniversal, ber.TypePrimitive, ber.TagOctetString, nil, "Control Value (Paging)")
        seq := ber.Encode(ber.ClassUniversal, ber.TypeConstructed, ber.TagSequence, nil, "Search Control Value")
        seq.AppendChild(ber.NewInteger(ber.ClassUniversal, ber.TypePrimitive, ber.TagInteger, int64(c.PagingSize), "Paging Size"))
        cookie := ber.Encode(ber.ClassUniversal, ber.TypePrimitive, ber.TagOctetString, nil, "Cookie")
        cookie.Value = c.Cookie
        cookie.Data.Write(c.Cookie)
        seq.AppendChild(cookie)
        p2.AppendChild(seq)

        packet.AppendChild(p2)
        return packet
}</span>

// String returns a human-readable description
func (c *ControlPaging) String() string <span class="cov8" title="1">{
        return fmt.Sprintf(
                "Control Type: %s (%q)  Criticality: %t  PagingSize: %d  Cookie: %q",
                ControlTypeMap[ControlTypePaging],
                ControlTypePaging,
                false,
                c.PagingSize,
                c.Cookie)
}</span>

// SetCookie stores the given cookie in the paging control
func (c *ControlPaging) SetCookie(cookie []byte) <span class="cov8" title="1">{
        c.Cookie = cookie
}</span>

// NewControlPaging returns a paging control
func NewControlPaging(pagingSize uint32, _ ...Option) (*ControlPaging, error) <span class="cov8" title="1">{
        return &amp;ControlPaging{PagingSize: pagingSize}, nil
}</span>

func addControlDescriptions(packet *ber.Packet) error <span class="cov8" title="1">{
        const op = "gldap.addControlDescriptions"
        if packet == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%s: missing packet: %w", op, ErrInvalidParameter)
        }</span>
        <span class="cov8" title="1">packet.Description = "Controls"
        for _, child := range packet.Children </span><span class="cov8" title="1">{
                var value *ber.Packet
                controlType := ""
                child.Description = "Control"
                switch len(child.Children) </span>{
                case 0:<span class="cov8" title="1">
                        // at least one child is required for control type
                        return fmt.Errorf("at least one child is required for a control type")</span>

                case 1:<span class="cov8" title="1">
                        // just type, no criticality or value
                        controlType = child.Children[0].Value.(string)
                        child.Children[0].Description = "Control Type (" + ControlTypeMap[controlType] + ")"</span>

                case 2:<span class="cov8" title="1">
                        controlType = child.Children[0].Value.(string)
                        child.Children[0].Description = "Control Type (" + ControlTypeMap[controlType] + ")"
                        // Children[1] could be criticality or value (both are optional)
                        // duck-type on whether this is a boolean
                        if _, ok := child.Children[1].Value.(bool); ok </span><span class="cov8" title="1">{
                                child.Children[1].Description = "Criticality"
                        }</span> else<span class="cov8" title="1"> {
                                child.Children[1].Description = "Control Value"
                                value = child.Children[1]
                        }</span>

                case 3:<span class="cov8" title="1">
                        // criticality and value present
                        controlType = child.Children[0].Value.(string)
                        child.Children[0].Description = "Control Type (" + ControlTypeMap[controlType] + ")"
                        child.Children[1].Description = "Criticality"
                        child.Children[2].Description = "Control Value"
                        value = child.Children[2]</span>

                default:<span class="cov8" title="1">
                        // more than 3 children is invalid
                        return fmt.Errorf("more than 3 children for control packet found")</span>
                }

                <span class="cov8" title="1">if value == nil </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">switch controlType </span>{
                case ControlTypePaging:<span class="cov8" title="1">
                        value.Description += " (Paging)"
                        if value.Value != nil </span><span class="cov0" title="0">{
                                valueChildren, err := ber.DecodePacketErr(value.Data.Bytes())
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to decode data bytes: %s", err)
                                }</span>
                                <span class="cov0" title="0">value.Data.Truncate(0)
                                value.Value = nil
                                valueChildren.Children[1].Value = valueChildren.Children[1].Data.Bytes()
                                value.AppendChild(valueChildren)</span>
                        }
                        <span class="cov8" title="1">value.Children[0].Description = "Real Search Control Value"
                        value.Children[0].Children[0].Description = "Paging Size"
                        value.Children[0].Children[1].Description = "Cookie"</span>

                case ControlTypeBeheraPasswordPolicy:<span class="cov8" title="1">
                        value.Description += " (Password Policy - Behera Draft)"
                        if value.Value != nil </span><span class="cov8" title="1">{
                                valueChildren, err := ber.DecodePacketErr(value.Data.Bytes())
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to decode data bytes: %s", err)
                                }</span>
                                <span class="cov8" title="1">value.Data.Truncate(0)
                                value.Value = nil
                                value.AppendChild(valueChildren)</span>
                        }
                        <span class="cov8" title="1">sequence := value.Children[0]
                        for _, child := range sequence.Children </span><span class="cov8" title="1">{
                                if child.Tag == 0 </span><span class="cov8" title="1">{
                                        // Warning
                                        warningPacket := child.Children[0]
                                        val, err := ber.ParseInt64(warningPacket.Data.Bytes())
                                        if err != nil </span><span class="cov0" title="0">{
                                                return fmt.Errorf("failed to decode data bytes: %s", err)
                                        }</span>
                                        <span class="cov8" title="1">if warningPacket.Tag == 0 </span><span class="cov8" title="1">{
                                                // timeBeforeExpiration
                                                value.Description += " (TimeBeforeExpiration)"
                                                warningPacket.Value = val
                                        }</span> else<span class="cov8" title="1"> if warningPacket.Tag == 1 </span><span class="cov8" title="1">{
                                                // graceAuthNsRemaining
                                                value.Description += " (GraceAuthNsRemaining)"
                                                warningPacket.Value = val
                                        }</span>
                                } else<span class="cov8" title="1"> if child.Tag == 1 </span><span class="cov8" title="1">{
                                        // Error
                                        bs := child.Data.Bytes()
                                        if len(bs) != 1 || bs[0] &gt; 8 </span><span class="cov0" title="0">{
                                                return fmt.Errorf("failed to decode data bytes: %s", "invalid PasswordPolicyResponse enum value")
                                        }</span>
                                        <span class="cov8" title="1">val := int8(bs[0])
                                        child.Description = "Error"
                                        child.Value = val</span>
                                }
                        }
                }
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package gldap

type controlOptions struct {
        withGrace        int
        withExpire       int
        withErrorCode    int
        withCriticality  bool
        withControlValue string

        // test options
        withTestType     string
        withTestToString string
}

func controlDefaults() controlOptions <span class="cov8" title="1">{
        return controlOptions{
                withGrace:     -1,
                withExpire:    -1,
                withErrorCode: -1,
        }
}</span>

func getControlOpts(opt ...Option) controlOptions <span class="cov8" title="1">{
        opts := controlDefaults()
        applyOpts(&amp;opts, opt...)
        return opts
}</span>

// WithGraceAuthNsRemaining specifies the number of grace authentication
// remaining.
func WithGraceAuthNsRemaining(remaining uint) Option <span class="cov8" title="1">{
        return func(o interface{}) </span><span class="cov8" title="1">{
                if o, ok := o.(*controlOptions); ok </span><span class="cov8" title="1">{
                        o.withGrace = int(remaining)
                }</span>
        }
}

// WithSecondsBeforeExpiration specifies the number of seconds before a password
// will expire
func WithSecondsBeforeExpiration(seconds uint) Option <span class="cov8" title="1">{
        return func(o interface{}) </span><span class="cov8" title="1">{
                if o, ok := o.(*controlOptions); ok </span><span class="cov8" title="1">{
                        o.withExpire = int(seconds)
                }</span>
        }
}

// WithErrorCode specifies the error code
func WithErrorCode(code uint) Option <span class="cov8" title="1">{
        return func(o interface{}) </span><span class="cov8" title="1">{
                if o, ok := o.(*controlOptions); ok </span><span class="cov8" title="1">{
                        o.withErrorCode = int(code)
                }</span>
        }
}

// WithCriticality specifies the criticality
func WithCriticality(criticality bool) Option <span class="cov8" title="1">{
        return func(o interface{}) </span><span class="cov8" title="1">{
                if o, ok := o.(*controlOptions); ok </span><span class="cov8" title="1">{
                        o.withCriticality = criticality
                }</span>
        }
}

// WithControlValue specifies the control value
func WithControlValue(value string) Option <span class="cov8" title="1">{
        return func(o interface{}) </span><span class="cov8" title="1">{
                if o, ok := o.(*controlOptions); ok </span><span class="cov8" title="1">{
                        o.withControlValue = value
                }</span>
        }
}

func withTestType(s string) Option <span class="cov8" title="1">{
        return func(o interface{}) </span><span class="cov8" title="1">{
                if o, ok := o.(*controlOptions); ok </span><span class="cov8" title="1">{
                        o.withTestType = s
                }</span>
        }
}

func withTestToString(s string) Option <span class="cov8" title="1">{
        return func(o interface{}) </span><span class="cov8" title="1">{
                if o, ok := o.(*controlOptions); ok </span><span class="cov8" title="1">{
                        o.withTestToString = s
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package gldap

import (
        "fmt"
        "os"
        "sort"
        "strings"

        ber "github.com/go-asn1-ber/asn1-ber"
)

// Entry represents an ldap entry
type Entry struct {
        // DN is the distinguished name of the entry
        DN string
        // Attributes are the returned attributes for the entry
        Attributes []*EntryAttribute
}

// GetAttributeValues returns the values for the named attribute, or an empty list
func (e *Entry) GetAttributeValues(attribute string) []string <span class="cov8" title="1">{
        for _, attr := range e.Attributes </span><span class="cov8" title="1">{
                if attr.Name == attribute </span><span class="cov8" title="1">{
                        return attr.Values
                }</span>
        }
        <span class="cov8" title="1">return []string{}</span>
}

// NewEntry returns an Entry object with the specified distinguished name and attribute key-value pairs.
// The map of attributes is accessed in alphabetical order of the keys in order to ensure that, for the
// same input map of attributes, the output entry will contain the same order of attributes
func NewEntry(dn string, attributes map[string][]string) *Entry <span class="cov8" title="1">{
        var attributeNames []string
        for attributeName := range attributes </span><span class="cov8" title="1">{
                attributeNames = append(attributeNames, attributeName)
        }</span>
        <span class="cov8" title="1">sort.Strings(attributeNames)

        var encodedAttributes []*EntryAttribute
        for _, attributeName := range attributeNames </span><span class="cov8" title="1">{
                encodedAttributes = append(encodedAttributes, NewEntryAttribute(attributeName, attributes[attributeName]))
        }</span>
        <span class="cov8" title="1">return &amp;Entry{
                DN:         dn,
                Attributes: encodedAttributes,
        }</span>
}

// PrettyPrint outputs a human-readable description indenting.  Supported
// options: WithWriter
func (e *Entry) PrettyPrint(indent int, opt ...Option) <span class="cov8" title="1">{
        opts := getGeneralOpts(opt...)
        if opts.withWriter == nil </span><span class="cov8" title="1">{
                opts.withWriter = os.Stdout
        }</span>
        <span class="cov8" title="1">fmt.Fprintf(opts.withWriter, "%sDN: %s\n", strings.Repeat(" ", indent), e.DN)
        for _, attr := range e.Attributes </span><span class="cov8" title="1">{
                attr.PrettyPrint(indent+2, opt...)
        }</span>
}

// PrettyPrint outputs a human-readable description with indenting.  Supported
// options: WithWriter
func (e *EntryAttribute) PrettyPrint(indent int, opt ...Option) <span class="cov8" title="1">{
        opts := getGeneralOpts(opt...)
        if opts.withWriter == nil </span><span class="cov8" title="1">{
                opts.withWriter = os.Stdout
        }</span>
        <span class="cov8" title="1">fmt.Fprintf(opts.withWriter, "%s%s: %s\n", strings.Repeat(" ", indent), e.Name, e.Values)</span>
}

// EntryAttribute holds a single attribute
type EntryAttribute struct {
        // Name is the name of the attribute
        Name string
        // Values contain the string values of the attribute
        Values []string
        // ByteValues contain the raw values of the attribute
        ByteValues [][]byte
}

// NewEntryAttribute returns a new EntryAttribute with the desired key-value pair
func NewEntryAttribute(name string, values []string) *EntryAttribute <span class="cov8" title="1">{
        var bytes [][]byte
        for _, value := range values </span><span class="cov8" title="1">{
                bytes = append(bytes, []byte(value))
        }</span>
        <span class="cov8" title="1">return &amp;EntryAttribute{
                Name:       name,
                Values:     values,
                ByteValues: bytes,
        }</span>
}

// AddValue to an existing EntryAttribute
func (e *EntryAttribute) AddValue(value ...string) <span class="cov8" title="1">{
        for _, v := range value </span><span class="cov8" title="1">{
                e.ByteValues = append(e.ByteValues, []byte(v))
                e.Values = append(e.Values, v)
        }</span>
}

func (e *EntryAttribute) encode() *ber.Packet <span class="cov8" title="1">{
        seq := ber.Encode(ber.ClassUniversal, ber.TypeConstructed, ber.TagSequence, nil, "Attribute")
        seq.AppendChild(ber.NewString(ber.ClassUniversal, ber.TypePrimitive, ber.TagOctetString, e.Name, "Type"))
        set := ber.Encode(ber.ClassUniversal, ber.TypeConstructed, ber.TagSet, nil, "AttributeValue")
        for _, value := range e.Values </span><span class="cov8" title="1">{
                set.AppendChild(ber.NewString(ber.ClassUniversal, ber.TypePrimitive, ber.TagOctetString, value, "Vals"))
        }</span>
        <span class="cov8" title="1">seq.AppendChild(set)
        return seq</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package gldap

import (
        "fmt"
)

// Scope represents the scope of a search (see: https://ldap.com/the-ldap-search-operation/)
type Scope int64

const (
        // BaseObject (often referred to as “base”): Indicates that only the entry
        // specified as the search base should be considered. None of its
        // subordinates will be considered.
        BaseObject Scope = 0

        // SingleLevel (often referred to as “one”): Indicates that only the
        // immediate children of the entry specified as the search base should be
        // considered. The base entry itself should not be considered, nor any
        // descendants of the immediate children of the base entry.
        SingleLevel Scope = 1

        // WholeSubtree (often referred to as “sub”): Indicates that the entry
        // specified as the search base, and all of its subordinates to any depth,
        // should be considered. Note that in the special case that the search base
        // DN is the null DN, the root DSE should not be considered in a
        // wholeSubtree search.
        WholeSubtree Scope = 2
)

// AuthChoice defines the authentication choice for bind message
type AuthChoice string

// SimpleAuthChoice specifies a simple user/password authentication choice for
// the bind message
const SimpleAuthChoice AuthChoice = "simple"

type requestType string

const (
        unknownRequestType  requestType = ""
        bindRequestType     requestType = "bind"
        searchRequestType   requestType = "search"
        extendedRequestType requestType = "extended"
        modifyRequestType   requestType = "modify"
        addRequestType      requestType = "add"
        deleteRequestType   requestType = "delete"
        unbindRequestType   requestType = "unbind"
)

// Message defines a common interface for all messages
type Message interface {
        // GetID returns the message ID
        GetID() int64
}

// baseMessage defines a common base type for all messages (typically embedded)
type baseMessage struct {
        id int64
}

// GetID() returns the message ID
func (m baseMessage) GetID() int64 <span class="cov8" title="1">{ return m.id }</span>

// SearchMessage is a search request message
type SearchMessage struct {
        baseMessage
        // BaseDN for the request
        BaseDN string
        // Scope of the request
        Scope Scope
        // DerefAliases for the request
        DerefAliases int
        // TimeLimit is the max time in seconds to spend processing
        TimeLimit int64
        // SizeLimit is the max number of results to return
        SizeLimit int64
        // TypesOnly is true if the client only expects type info
        TypesOnly bool
        // Filter for the request
        Filter string
        // Attributes requested
        Attributes []string
        // Controls requested
        Controls []Control
}

// SimpleBindMessage is a simple bind request message
type SimpleBindMessage struct {
        baseMessage
        // AuthChoice for the request (SimpleAuthChoice)
        AuthChoice AuthChoice
        // UserName for the bind request
        UserName string
        // Password for the bind request
        Password Password
        // Controls are optional controls for the bind request
        Controls []Control
}

// ExtendedOperationMessage is an extended operation request message
type ExtendedOperationMessage struct {
        baseMessage
        // Name of the extended operation
        Name ExtendedOperationName
        // Value of the extended operation
        Value string
}

// DeleteMessage is an delete request message
type DeleteMessage struct {
        baseMessage
        // DN identifies the entry being added
        DN string

        // Controls hold optional controls to send with the request
        Controls []Control
}

// UnbindMessage is an unbind request message
type UnbindMessage struct {
        baseMessage
}

// newMessage will create a new message from the packet.
func newMessage(p *packet) (Message, error) <span class="cov8" title="1">{
        const op = "gldap.NewMessage"

        reqType, err := p.requestType()
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">msgID, err := p.requestMessageID()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: unable to get message id: %w", op, err)
        }</span>

        <span class="cov8" title="1">switch reqType </span>{
        case unbindRequestType:<span class="cov8" title="1">
                return &amp;UnbindMessage{
                        baseMessage: baseMessage{
                                id: msgID,
                        },
                }, nil</span>
        case bindRequestType:<span class="cov8" title="1">
                u, pass, controls, err := p.simpleBindParameters()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%s: invalid bind message: %w", op, err)
                }</span>
                <span class="cov8" title="1">return &amp;SimpleBindMessage{
                        baseMessage: baseMessage{
                                id: msgID,
                        },
                        UserName:   u,
                        Password:   pass,
                        AuthChoice: SimpleAuthChoice,
                        Controls:   controls,
                }, nil</span>
        case searchRequestType:<span class="cov8" title="1">
                parameters, err := p.searchParmeters()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%s: invalid search message: %w", op, err)
                }</span>
                <span class="cov8" title="1">return &amp;SearchMessage{
                        baseMessage: baseMessage{
                                id: msgID,
                        },
                        BaseDN:       parameters.baseDN,
                        Scope:        Scope(parameters.scope),
                        DerefAliases: int(parameters.derefAliases),
                        SizeLimit:    parameters.sizeLimit,
                        TimeLimit:    parameters.timeLimit,
                        TypesOnly:    parameters.typesOnly,
                        Filter:       parameters.filter,
                        Attributes:   parameters.attributes,
                        Controls:     parameters.controls,
                }, nil</span>
        case extendedRequestType:<span class="cov8" title="1">
                opName, err := p.extendedOperationName()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%s: %w", op, err)
                }</span>
                <span class="cov8" title="1">return &amp;ExtendedOperationMessage{
                        baseMessage: baseMessage{
                                id: msgID,
                        },
                        Name: opName,
                }, nil</span>
        case modifyRequestType:<span class="cov8" title="1">
                parameters, err := p.modifyParameters()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%s: %w", op, err)
                }</span>
                <span class="cov8" title="1">return &amp;ModifyMessage{
                        baseMessage: baseMessage{
                                id: msgID,
                        },
                        DN:       parameters.dn,
                        Changes:  parameters.changes,
                        Controls: parameters.controls,
                }, nil</span>
        case addRequestType:<span class="cov8" title="1">
                parameters, err := p.addParameters()
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("%s: %w", op, err)
                }</span>
                <span class="cov8" title="1">return &amp;AddMessage{
                        baseMessage: baseMessage{
                                id: msgID,
                        },
                        DN:         parameters.dn,
                        Attributes: parameters.attributes,
                        Controls:   parameters.controls,
                }, nil</span>
        case deleteRequestType:<span class="cov8" title="1">
                dn, controls, err := p.deleteParameters()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%s: %w", op, err)
                }</span>
                <span class="cov8" title="1">return &amp;DeleteMessage{
                        baseMessage: baseMessage{
                                id: msgID,
                        },
                        DN:       dn,
                        Controls: controls,
                }, nil</span>
        default:<span class="cov0" title="0">
                return &amp;ExtendedOperationMessage{
                        baseMessage: baseMessage{
                                id: msgID,
                        },
                        Name: ExtendedOperationUnknown,
                }, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package gldap

import ber "github.com/go-asn1-ber/asn1-ber"

type messageOptions struct {
        withMinChildren *int
        withLenChildren *int
        withAssertChild *int
        withTag         *ber.Tag
}

func messageDefaults() messageOptions <span class="cov8" title="1">{
        return messageOptions{}
}</span>

func getMessageOpts(opt ...Option) messageOptions <span class="cov8" title="1">{
        opts := messageDefaults()
        applyOpts(&amp;opts, opt...)
        return opts
}</span>

func withMinChildren(min int) Option <span class="cov8" title="1">{
        return func(o interface{}) </span><span class="cov8" title="1">{
                if o, ok := o.(*messageOptions); ok </span><span class="cov8" title="1">{
                        o.withMinChildren = &amp;min
                }</span>
        }
}

// we'll see if we start using this again in the near future,
// but for now ignore the warning
//
//nolint:unused
func withLenChildren(len int) Option <span class="cov0" title="0">{
        return func(o interface{}) </span><span class="cov0" title="0">{
                if o, ok := o.(*messageOptions); ok </span><span class="cov0" title="0">{
                        o.withLenChildren = &amp;len
                }</span>
        }
}

func withAssertChild(idx int) Option <span class="cov8" title="1">{
        return func(o interface{}) </span><span class="cov8" title="1">{
                if o, ok := o.(*messageOptions); ok </span><span class="cov8" title="1">{
                        o.withAssertChild = &amp;idx
                }</span>
        }
}

func withTag(t ber.Tag) Option <span class="cov8" title="1">{
        return func(o interface{}) </span><span class="cov8" title="1">{
                if o, ok := o.(*messageOptions); ok </span><span class="cov8" title="1">{
                        o.withTag = &amp;t
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package gldap

import ber "github.com/go-asn1-ber/asn1-ber"

// Change operation choices
const (
        AddAttribute       = 0
        DeleteAttribute    = 1
        ReplaceAttribute   = 2
        IncrementAttribute = 3 // (https://tools.ietf.org/html/rfc4525)
)

// ModifyMessage as defined in https://tools.ietf.org/html/rfc4511
type ModifyMessage struct {
        baseMessage
        DN       string
        Changes  []Change
        Controls []Control
}

// Change for a ModifyMessage as defined in https://tools.ietf.org/html/rfc4511
type Change struct {
        // Operation is the type of change to be made
        Operation int64
        // Modification is the attribute to be modified
        Modification PartialAttribute
}

// PartialAttribute for a ModifyMessage as defined in https://tools.ietf.org/html/rfc4511
type PartialAttribute struct {
        // Type is the type of the partial attribute
        Type string
        // Vals are the values of the partial attribute
        Vals []string
}

func (c *Change) encode() *ber.Packet <span class="cov8" title="1">{
        change := ber.Encode(ber.ClassUniversal, ber.TypeConstructed, ber.TagSequence, nil, "Change")
        change.AppendChild(ber.NewInteger(ber.ClassUniversal, ber.TypePrimitive, ber.TagEnumerated, int64(c.Operation), "Operation"))
        change.AppendChild(c.Modification.encode())
        return change
}</span>

func (p *PartialAttribute) encode() *ber.Packet <span class="cov8" title="1">{
        seq := ber.Encode(ber.ClassUniversal, ber.TypeConstructed, ber.TagSequence, nil, "PartialAttribute")
        seq.AppendChild(ber.NewString(ber.ClassUniversal, ber.TypePrimitive, ber.TagOctetString, p.Type, "Type"))
        set := ber.Encode(ber.ClassUniversal, ber.TypeConstructed, ber.TagSet, nil, "AttributeValue")
        for _, value := range p.Vals </span><span class="cov8" title="1">{
                set.AppendChild(ber.NewString(ber.ClassUniversal, ber.TypePrimitive, ber.TagOctetString, value, "Vals"))
        }</span>
        <span class="cov8" title="1">seq.AppendChild(set)
        return seq</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package gldap

import (
        "fmt"
        "sync"
)

// Mux is an ldap request multiplexer. It matches the inbound request against a
// list of registered route handlers. Routes are matched in the order they're
// added and only one route is called per request.
type Mux struct {
        mu           sync.Mutex
        routes       []route
        defaultRoute route
        unbindRoute  route
}

// NewMux creates a new multiplexer.
func NewMux(opt ...Option) (*Mux, error) <span class="cov8" title="1">{
        return &amp;Mux{
                routes: []route{},
        }, nil
}</span>

// Bind will register a handler for bind requests.
// Options supported: WithLabel
func (m *Mux) Bind(bindFn HandlerFunc, opt ...Option) error <span class="cov8" title="1">{
        const op = "gldap.(Mux).Bind"
        if bindFn == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: missing HandlerFunc: %w", op, ErrInvalidParameter)
        }</span>
        <span class="cov8" title="1">opts := getRouteOpts(opt...)

        r := &amp;simpleBindRoute{
                baseRoute: &amp;baseRoute{
                        h:       bindFn,
                        routeOp: bindRouteOperation,
                        label:   opts.withLabel,
                },
                authChoice: SimpleAuthChoice,
        }
        m.mu.Lock()
        defer m.mu.Unlock()
        m.routes = append(m.routes, r)
        return nil</span>
}

// Unbind will register a handler for unbind requests and override the default
// unbind handler.  Registering an unbind handler is optional and regardless of
// whether or not an unbind route is defined the server will stop serving
// requests for a connection after an unbind request is received.  Options
// supported: WithLabel
func (m *Mux) Unbind(bindFn HandlerFunc, opt ...Option) error <span class="cov8" title="1">{
        const op = "gldap.(Mux).Unbind"
        if bindFn == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%s: missing HandlerFunc: %w", op, ErrInvalidParameter)
        }</span>
        <span class="cov8" title="1">opts := getRouteOpts(opt...)

        r := &amp;unbindRoute{
                baseRoute: &amp;baseRoute{
                        h:       bindFn,
                        routeOp: bindRouteOperation,
                        label:   opts.withLabel,
                },
        }
        m.mu.Lock()
        defer m.mu.Unlock()
        m.unbindRoute = r
        return nil</span>
}

// Search will register a handler for search requests.
// Options supported: WithLabel, WithBaseDN, WithScope
func (m *Mux) Search(searchFn HandlerFunc, opt ...Option) error <span class="cov8" title="1">{
        const op = "gldap.(Mux).Search"
        if searchFn == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: missing HandlerFunc: %w", op, ErrInvalidParameter)
        }</span>
        <span class="cov8" title="1">opts := getRouteOpts(opt...)
        r := &amp;searchRoute{
                baseRoute: &amp;baseRoute{
                        h:       searchFn,
                        routeOp: searchRouteOperation,
                        label:   opts.withLabel,
                },
                basedn: opts.withBaseDN,
                filter: opts.withFilter,
                scope:  opts.withScope,
        }
        m.mu.Lock()
        defer m.mu.Unlock()
        m.routes = append(m.routes, r)
        return nil</span>
}

// ExtendedOperation will register a handler for extended operation requests.
// Options supported: WithLabel
func (m *Mux) ExtendedOperation(operationFn HandlerFunc, exName ExtendedOperationName, opt ...Option) error <span class="cov8" title="1">{
        const op = "gldap.(Mux).Search"
        if operationFn == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: missing HandlerFunc: %w", op, ErrInvalidParameter)
        }</span>
        <span class="cov8" title="1">opts := getRouteOpts(opt...)
        r := &amp;extendedRoute{
                baseRoute: &amp;baseRoute{
                        h:       operationFn,
                        routeOp: extendedRouteOperation,
                        label:   opts.withLabel,
                },
                extendedName: exName,
        }
        m.mu.Lock()
        defer m.mu.Unlock()
        m.routes = append(m.routes, r)
        return nil</span>
}

// Modify will register a handler for modify operation requests.
// Options supported: WithLabel
func (m *Mux) Modify(modifyFn HandlerFunc, opt ...Option) error <span class="cov8" title="1">{
        const op = "gldap.(Mux).Modify"
        if modifyFn == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: missing HandlerFunc: %w", op, ErrInvalidParameter)
        }</span>
        <span class="cov8" title="1">opts := getRouteOpts(opt...)
        r := &amp;modifyRoute{
                baseRoute: &amp;baseRoute{
                        h:       modifyFn,
                        routeOp: modifyRouteOperation,
                        label:   opts.withLabel,
                },
        }
        m.mu.Lock()
        defer m.mu.Unlock()
        m.routes = append(m.routes, r)
        return nil</span>
}

// Add will register a handler for add operation requests.
// Options supported: WithLabel
func (m *Mux) Add(addFn HandlerFunc, opt ...Option) error <span class="cov8" title="1">{
        const op = "gldap.(Mux).Add"
        if addFn == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: missing HandlerFunc: %w", op, ErrInvalidParameter)
        }</span>
        <span class="cov8" title="1">opts := getRouteOpts(opt...)
        r := &amp;addRoute{
                baseRoute: &amp;baseRoute{
                        h:       addFn,
                        routeOp: addRouteOperation,
                        label:   opts.withLabel,
                },
        }
        m.mu.Lock()
        defer m.mu.Unlock()
        m.routes = append(m.routes, r)
        return nil</span>
}

// Delete will register a handler for delete operation requests.
// Options supported: WithLabel
func (m *Mux) Delete(modifyFn HandlerFunc, opt ...Option) error <span class="cov8" title="1">{
        const op = "gldap.(Mux).Delete"
        if modifyFn == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%s: missing HandlerFunc: %w", op, ErrInvalidParameter)
        }</span>
        <span class="cov8" title="1">opts := getRouteOpts(opt...)
        r := &amp;deleteRoute{
                baseRoute: &amp;baseRoute{
                        h:       modifyFn,
                        routeOp: deleteRouteOperation,
                        label:   opts.withLabel,
                },
        }
        m.mu.Lock()
        defer m.mu.Unlock()
        m.routes = append(m.routes, r)
        return nil</span>
}

// DefaultRoute will register a default handler requests which have no other
// registered handler.
func (m *Mux) DefaultRoute(noRouteFN HandlerFunc, opt ...Option) error <span class="cov8" title="1">{
        const op = "gldap.(Mux).Bind"
        if noRouteFN == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: missing HandlerFunc: %w", op, ErrInvalidParameter)
        }</span>
        <span class="cov8" title="1">r := &amp;baseRoute{
                h:       noRouteFN,
                routeOp: bindRouteOperation,
        }
        m.mu.Lock()
        defer m.mu.Unlock()
        m.defaultRoute = r
        return nil</span>
}

// serveRequests will find a matching route to serve the request
func (m *Mux) serve(w *ResponseWriter, req *Request) <span class="cov8" title="1">{
        const op = "gldap.(Mux).serve"
        defer func() </span><span class="cov8" title="1">{
                w.logger.Debug("finished serving request", "op", op, "connID", w.connID, "requestID", w.requestID)
        }</span>()
        <span class="cov8" title="1">if w == nil </span><span class="cov8" title="1">{
                // this should be unreachable, and if it is then we'll just panic
                panic(fmt.Errorf("%s: %d/%d missing response writer: %w", op, w.connID, w.requestID, ErrInternal).Error())</span>
        }
        <span class="cov8" title="1">if req == nil </span><span class="cov8" title="1">{
                w.logger.Error("missing request", "op", op, "connID", w.connID, "requestID", w.requestID)
                return
        }</span>

        // find the first matching route to dispatch the request to and then return
        <span class="cov8" title="1">for _, r := range m.routes </span><span class="cov8" title="1">{
                if !r.match(req) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">h := r.handler()
                if h == nil </span><span class="cov0" title="0">{
                        w.logger.Error("route is missing handler", "op", op, "connID", w.connID, "requestID", w.requestID, "route", r.op)
                        return
                }</span>
                // the handler intentionally doesn't return errors, since we want the
                // handler to response to the connection's client with errors.
                <span class="cov8" title="1">h(w, req)
                return</span>
        }
        <span class="cov8" title="1">if m.defaultRoute != nil </span><span class="cov8" title="1">{
                h := m.defaultRoute.handler()
                h(w, req)
                return
        }</span>
        <span class="cov8" title="1">w.logger.Error("no matching handler found for request and returning internal error", "op", op, "connID", w.connID, "requestID", w.requestID, "routeOp", req.routeOp)
        resp := req.NewResponse(WithResponseCode(ResultUnwillingToPerform), WithDiagnosticMessage("No matching handler found"))
        _ = w.Write(resp)</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package gldap

import (
        "io"
        "reflect"
)

// Option defines a common functional options type which can be used in a
// variadic parameter pattern.
type Option func(interface{})

// applyOpts takes a pointer to the options struct as a set of default options
// and applies the slice of opts as overrides.
func applyOpts(opts interface{}, opt ...Option) <span class="cov8" title="1">{
        for _, o := range opt </span><span class="cov8" title="1">{
                if o == nil </span><span class="cov8" title="1">{ // ignore any nil Options
                        continue</span>
                }
                <span class="cov8" title="1">o(opts)</span>
        }
}

type generalOptions struct {
        withWriter io.Writer
}

func generalDefaults() generalOptions <span class="cov8" title="1">{
        return generalOptions{}
}</span>

func getGeneralOpts(opt ...Option) generalOptions <span class="cov8" title="1">{
        opts := generalDefaults()
        applyOpts(&amp;opts, opt...)
        return opts
}</span>

// WithWriter allows you to specify an optional writer.
func WithWriter(w io.Writer) Option <span class="cov8" title="1">{
        return func(o interface{}) </span><span class="cov8" title="1">{
                if o, ok := o.(*generalOptions); ok </span><span class="cov8" title="1">{
                        if !isNil(w) </span><span class="cov8" title="1">{
                                o.withWriter = w
                        }</span>
                }
        }
}

func isNil(i interface{}) bool <span class="cov8" title="1">{
        if i == nil </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">switch reflect.TypeOf(i).Kind() </span>{
        case reflect.Ptr, reflect.Map, reflect.Array, reflect.Chan, reflect.Slice:<span class="cov8" title="1">
                return reflect.ValueOf(i).IsNil()</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package gldap

import (
        "fmt"
        "io"

        ber "github.com/go-asn1-ber/asn1-ber"
        "github.com/go-ldap/ldap/v3"
        "github.com/hashicorp/go-hclog"
)

type packet struct {
        *ber.Packet
        validated bool
}

func (p *packet) basicValidation() error <span class="cov8" title="1">{
        const (
                op = "gldap.(packet).basicValidation"

                // messageID packet + Request packet
                childMinChildren = 2
        )
        if p.validated </span><span class="cov8" title="1">{
                return nil
        }</span>
        // Simple header is first... let's make sure it's an ldap packet with 2
        // children containing:
        //                [0] is a message ID
        //                [1] is a request header
        <span class="cov8" title="1">if err := p.assert(ber.ClassUniversal, ber.TypeConstructed, withTag(ber.TagSequence), withMinChildren(childMinChildren)); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%s: invalid ldap packet 0: %w", op, ErrInvalidParameter)
        }</span>
        <span class="cov8" title="1">p.validated = true
        return nil</span>
}

func (p *packet) requestMessageID() (int64, error) <span class="cov8" title="1">{
        const (
                op = "gldap.(packet).requestMessageID"

                childMessageID = 0
        )
        if err := p.basicValidation(); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("%s: %w", op, err)
        }</span>
        <span class="cov8" title="1">msgIDPacket := &amp;packet{Packet: p.Children[childMessageID]}
        // assert it's capable of holding the message ID
        if err := msgIDPacket.assert(ber.ClassUniversal, ber.TypePrimitive, withTag(ber.TagInteger)); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("%s: missing/invalid packet: %w", op, err)
        }</span>
        <span class="cov8" title="1">id, ok := msgIDPacket.Value.(int64)
        if !ok </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("%s: expected int64 message ID and got %t: %w", op, msgIDPacket.Value, ErrInvalidParameter)
        }</span>
        <span class="cov8" title="1">return id, nil</span>
}

// returns nil, nil if there's no control packet
func (p *packet) controlPacket() (*packet, error) <span class="cov8" title="1">{
        const (
                op = "gldap.(packet).controlPacket"

                childControl = 2
        )
        if len(p.Children) &lt;= 2 </span><span class="cov8" title="1">{
                // no control packet
                return nil, nil
        }</span>
        <span class="cov8" title="1">controlPacket := &amp;packet{Packet: p.Children[childControl]}
        if err := controlPacket.assert(ber.ClassContext, ber.TypeConstructed); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: invalid control packet: %w", op, ErrInvalidParameter)
        }</span>
        <span class="cov8" title="1">return controlPacket, nil</span>
}

func (p *packet) requestPacket() (*packet, error) <span class="cov8" title="1">{
        const (
                op = "gldap.(packet).requestPacket"

                childApplicationRequest = 1
                childVersionNumber      = 0 // first child of the app request packet
        )
        if err := p.basicValidation(); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%s: %w", op, err)
        }</span>
        <span class="cov8" title="1">if err := p.assertApplicationRequest(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: missing request child packet: %w", op, err)
        }</span>
        <span class="cov8" title="1">requestPacket := &amp;packet{Packet: p.Children[childApplicationRequest]}

        switch requestPacket.Packet.Tag </span>{
        case ApplicationBindRequest:<span class="cov8" title="1">
                // assert it's ldap v3
                if err := requestPacket.assert(ber.ClassUniversal, ber.TypePrimitive, withTag(ber.TagInteger), withAssertChild(childVersionNumber)); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%s: missing/invalid packet: %w", op, err)
                }</span>
                <span class="cov8" title="1">ldapVersion, ok := requestPacket.Packet.Children[childVersionNumber].Value.(int64)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%s: %v is not the expected int64 type: %w", op, requestPacket.Packet.Children[childVersionNumber].Value, ErrInvalidParameter)
                }</span>
                <span class="cov8" title="1">if ldapVersion != 3 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%s: incorrect ldap version, expected 3 but got %v", op, requestPacket.Value.(int64))
                }</span>
        default:<span class="cov8" title="1"></span>
                // nothing to do or see here, move along please... :)
        }

        <span class="cov8" title="1">return &amp;packet{Packet: p.Children[childApplicationRequest]}, nil</span>
}

func (p *packet) requestType() (requestType, error) <span class="cov8" title="1">{
        const op = "gldap.(Packet).requestType"
        requestPacket, err := p.requestPacket()
        if err != nil </span><span class="cov8" title="1">{
                return unknownRequestType, fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">switch requestPacket.Tag </span>{
        case ApplicationBindRequest:<span class="cov8" title="1">
                return bindRequestType, nil</span>
        case ApplicationSearchRequest:<span class="cov8" title="1">
                return searchRequestType, nil</span>
        case ApplicationExtendedRequest:<span class="cov8" title="1">
                return extendedRequestType, nil</span>
        case ApplicationModifyRequest:<span class="cov8" title="1">
                return modifyRequestType, nil</span>
        case ApplicationAddRequest:<span class="cov8" title="1">
                return addRequestType, nil</span>
        case ApplicationDelRequest:<span class="cov8" title="1">
                return deleteRequestType, nil</span>
        case ApplicationUnbindRequest:<span class="cov8" title="1">
                return unbindRequestType, nil</span>
        default:<span class="cov0" title="0">
                return unknownRequestType, fmt.Errorf("%s: unhandled request type %d: %w", op, requestPacket.Tag, ErrInternal)</span>
        }
}

type modifyParameters struct {
        dn       string
        changes  []Change
        controls []Control
}

// return the DN, changes, and controls
func (p *packet) modifyParameters() (*modifyParameters, error) <span class="cov8" title="1">{
        const (
                op = "gldap.(packet).modifyParameters"

                childDN                 = 0
                childChanges            = 1
                childOperation          = 0
                childModification       = 1
                childModificationType   = 0
                childModificationValues = 1
                childControls           = 2
        )
        requestPacket, err := p.requestPacket()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: %w", op, err)
        }</span>
        <span class="cov8" title="1">if requestPacket.Packet.Tag != ApplicationModifyRequest </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: not an modify request, expected tag %d and got %d: %w", op, ApplicationModifyRequest, requestPacket.Tag, ErrInvalidParameter)
        }</span>
        <span class="cov8" title="1">var parameters modifyParameters

        if err := requestPacket.assert(ber.ClassUniversal, ber.TypePrimitive, withTag(ber.TagOctetString), withAssertChild(childDN)); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: modify dn packet: %w", op, ErrInvalidParameter)
        }</span>
        <span class="cov8" title="1">parameters.dn = requestPacket.Children[childDN].Data.String()

        // assert changes packet
        if err := requestPacket.assert(ber.ClassUniversal, ber.TypeConstructed, withTag(ber.TagSequence), withAssertChild(childChanges)); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: modify changes packet: %w", op, ErrInvalidParameter)
        }</span>

        <span class="cov8" title="1">changesPacket := requestPacket.Children[childChanges]
        parameters.changes = make([]Change, 0, len(changesPacket.Children))
        for _, c := range changesPacket.Children </span><span class="cov8" title="1">{
                changePacket := packet{Packet: c}

                // assert this is a "Change" packet
                if err := changePacket.assert(ber.ClassUniversal, ber.TypeConstructed, withTag(ber.TagSequence)); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%s: modify changes child packet: %w", op, ErrInvalidParameter)
                }</span>
                // assert the change operation child
                <span class="cov8" title="1">if err := changePacket.assert(ber.ClassUniversal, ber.TypePrimitive, withTag(ber.TagEnumerated), withAssertChild(childOperation)); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%s: modify changes child operation packet: %w", op, ErrInvalidParameter)
                }</span>
                <span class="cov8" title="1">var ok bool
                var chg Change
                if chg.Operation, ok = changePacket.Children[childOperation].Value.(int64); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%s: change operation is not an int64: %t", op, changePacket.Children[childOperation].Value)
                }</span>

                // assert the change modification child
                <span class="cov8" title="1">if err := changePacket.assert(ber.ClassUniversal, ber.TypeConstructed, withTag(ber.TagSequence), withAssertChild(childModification)); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%s: change modification child packet: %w", op, ErrInvalidParameter)
                }</span>

                // get the modification type
                <span class="cov8" title="1">modificationPacket := packet{Packet: changePacket.Children[childModification]}
                if err := modificationPacket.assert(ber.ClassUniversal, ber.TypePrimitive, withTag(ber.TagOctetString), withAssertChild(childModificationType)); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%s: modification type packet: %w", op, ErrInvalidParameter)
                }</span>
                <span class="cov8" title="1">chg.Modification.Type = modificationPacket.Children[childModificationType].Data.String()

                // get the modification values
                if len(modificationPacket.Children) &lt; childModificationValues+1 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%s: missing modification values packet: %w", op, ErrInvalidParameter)
                }</span>
                <span class="cov8" title="1">chg.Modification.Vals = make([]string, 0, len(modificationPacket.Children)-1)
                for _, value := range modificationPacket.Children[1:] </span><span class="cov8" title="1">{
                        chg.Modification.Vals = append(chg.Modification.Vals, value.Data.String())
                }</span>

                <span class="cov8" title="1">parameters.changes = append(parameters.changes, chg)</span>
        }

        <span class="cov8" title="1">controlPacket, err := p.controlPacket()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: %w", op, err)
        }</span>
        <span class="cov8" title="1">if controlPacket != nil </span><span class="cov8" title="1">{
                parameters.controls = make([]Control, 0, len(controlPacket.Children))
                for _, c := range controlPacket.Children </span><span class="cov8" title="1">{
                        ctrl, err := decodeControl(c)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("%s: %w", op, err)
                        }</span>
                        <span class="cov8" title="1">parameters.controls = append(parameters.controls, ctrl)</span>
                }
        }

        <span class="cov8" title="1">return &amp;parameters, nil</span>
}

func (p *packet) extendedOperationName() (ExtendedOperationName, error) <span class="cov8" title="1">{
        const (
                op = "gldap.(Packet).simpleBindParameters"

                childExtendedOperationName = 0
        )
        requestPacket, err := p.requestPacket()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%s: %w", op, err)
        }</span>
        <span class="cov8" title="1">if requestPacket.Packet.Tag != ApplicationExtendedRequest </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%s: not an extended operation request, expected tag %d and got %d: %w", op, ApplicationExtendedRequest, requestPacket.Tag, ErrInvalidParameter)
        }</span>
        <span class="cov8" title="1">if err := requestPacket.assert(ber.ClassContext, ber.TypePrimitive, withTag(0), withAssertChild(childExtendedOperationName)); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%s: missing/invalid username packet: %w", op, ErrInvalidParameter)
        }</span>
        <span class="cov8" title="1">n := requestPacket.Children[childExtendedOperationName].Data.String()
        return ExtendedOperationName(n), nil</span>
}

// Password is a simple bind request password
type Password string

func (p *packet) simpleBindParameters() (string, Password, []Control, error) <span class="cov8" title="1">{
        const (
                op = "gldap.(Packet).simpleBindParameters"

                childBindUserName = 1
                childBindPassword = 2
        )
        requestPacket, err := p.requestPacket()
        if err != nil </span><span class="cov0" title="0">{
                return "", "", nil, fmt.Errorf("%s: %w", op, err)
        }</span>
        <span class="cov8" title="1">if err := requestPacket.assert(ber.ClassUniversal, ber.TypePrimitive, withTag(ber.TagOctetString), withAssertChild(childBindUserName)); err != nil </span><span class="cov0" title="0">{
                return "", "", nil, fmt.Errorf("%s: missing/invalid username packet: %w", op, ErrInvalidParameter)
        }</span>
        <span class="cov8" title="1">userName := requestPacket.Children[childBindUserName].Data.String()

        // check if there's even an password packet in the request
        if len(requestPacket.Children) &gt; 3 </span><span class="cov0" title="0">{
                return userName, "", nil, nil
        }</span>
        <span class="cov8" title="1">if err := requestPacket.assert(ber.ClassContext, ber.TypePrimitive, withTag(0), withAssertChild(childBindPassword)); err != nil </span><span class="cov0" title="0">{
                return "", "", nil, fmt.Errorf("%s: missing/invalid password packet: %w", op, ErrInvalidParameter)
        }</span>
        <span class="cov8" title="1">password := requestPacket.Children[childBindPassword].Data.String()

        var controls []Control
        controlPacket, err := p.controlPacket()
        if err != nil </span><span class="cov0" title="0">{
                return "", "", nil, fmt.Errorf("%s: %w", op, err)
        }</span>
        <span class="cov8" title="1">if controlPacket != nil </span><span class="cov8" title="1">{
                controls = make([]Control, 0, len(controlPacket.Children))
                for _, c := range controlPacket.Children </span><span class="cov8" title="1">{
                        ctrl, err := decodeControl(c)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", "", nil, fmt.Errorf("%s: %w", op, err)
                        }</span>
                        <span class="cov8" title="1">controls = append(controls, ctrl)</span>
                }
        }

        <span class="cov8" title="1">return userName, Password(password), controls, nil</span>
}

type addParameters struct {
        dn         string
        attributes []Attribute
        controls   []Control
}

// addParameters decodes the add request parameters from the packet
func (p *packet) addParameters() (*addParameters, error) <span class="cov8" title="1">{
        const op = "gldap.(Packet).addParameters"
        const (
                childDN         = 0
                childAttributes = 1
                childControls   = 2
        )
        var add addParameters
        requestPacket, err := p.requestPacket()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: %w", op, err)
        }</span>
        // validate that it's a search request
        <span class="cov8" title="1">if requestPacket.Packet.Tag != ApplicationAddRequest </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: not an add request, expected tag %d and got %d: %w", op, ApplicationAddRequest, requestPacket.Tag, ErrInvalidParameter)
        }</span>
        // DN child
        <span class="cov8" title="1">if err := requestPacket.assert(ber.ClassUniversal, ber.TypePrimitive, withTag(ber.TagOctetString), withAssertChild(childDN)); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: missing/invalid DN: %w", op, ErrInvalidParameter)
        }</span>
        <span class="cov8" title="1">add.dn = requestPacket.Children[childDN].Data.String()

        if err := requestPacket.assert(ber.ClassUniversal, ber.TypeConstructed, withTag(ber.TagSequence), withAssertChild(childAttributes)); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: missing/invalid attributes: %w", op, ErrInvalidParameter)
        }</span>
        <span class="cov8" title="1">attributesPackets := packet{
                Packet: requestPacket.Children[childAttributes],
        }
        for _, attribute := range attributesPackets.Children </span><span class="cov8" title="1">{
                attr, err := decodeAttribute(attribute)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("%s: failed to decode attribute packet: %w", op, err)
                }</span>
                <span class="cov8" title="1">add.attributes = append(add.attributes, *attr)</span>
        }

        <span class="cov8" title="1">controlPacket, err := p.controlPacket()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: %w", op, err)
        }</span>
        <span class="cov8" title="1">if controlPacket != nil </span><span class="cov8" title="1">{
                add.controls = make([]Control, 0, len(controlPacket.Children))
                for _, c := range controlPacket.Children </span><span class="cov8" title="1">{
                        ctrl, err := decodeControl(c)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("%s: %w", op, err)
                        }</span>
                        <span class="cov8" title="1">add.controls = append(add.controls, ctrl)</span>
                }
        }
        <span class="cov8" title="1">return &amp;add, nil</span>
}

type searchParameters struct {
        baseDN       string
        scope        int64
        derefAliases int64
        sizeLimit    int64
        timeLimit    int64
        typesOnly    bool
        filter       string
        attributes   []string
        controls     []Control
}

func (p *packet) searchParmeters() (*searchParameters, error) <span class="cov8" title="1">{
        const op = "gldap.(Packet).searchParmeters"
        const (
                childBaseDN       = 0
                childScope        = 1
                childDerefAliases = 2
                childSizeLimit    = 3
                childTimeLimit    = 4
                childTypesOnly    = 5
                childFilter       = 6
                childAttributes   = 7
        )
        var ok bool
        var searchFor searchParameters
        requestPacket, err := p.requestPacket()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: %w", op, err)
        }</span>
        // validate that it's a search request
        <span class="cov8" title="1">if requestPacket.Packet.Tag != ApplicationSearchRequest </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: not an search request, expected tag %d and got %d: %w", op, ApplicationSearchRequest, requestPacket.Tag, ErrInvalidParameter)
        }</span>
        // baseDN child
        <span class="cov8" title="1">if err := requestPacket.assert(ber.ClassUniversal, ber.TypePrimitive, withTag(ber.TagOctetString), withAssertChild(childBaseDN)); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: missing/invalid baseDN: %w", op, ErrInvalidParameter)
        }</span>
        <span class="cov8" title="1">searchFor.baseDN = requestPacket.Children[childBaseDN].Data.String()

        // scope child
        if err := requestPacket.assert(ber.ClassUniversal, ber.TypePrimitive, withTag(ber.TagEnumerated), withAssertChild(childScope)); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: missing/invalid scope: %w", op, ErrInvalidParameter)
        }</span>
        <span class="cov8" title="1">if searchFor.scope, ok = requestPacket.Children[childScope].Value.(int64); !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: scope is not an int64", op)
        }</span>

        // deref aliases
        <span class="cov8" title="1">if err := requestPacket.assert(ber.ClassUniversal, ber.TypePrimitive, withTag(ber.TagEnumerated), withAssertChild(childDerefAliases)); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: missing/invalid deref aliases: %w", op, ErrInvalidParameter)
        }</span>
        <span class="cov8" title="1">if searchFor.derefAliases, ok = requestPacket.Children[childDerefAliases].Value.(int64); !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: deref aliases is not an int64", op)
        }</span>

        // size limit
        <span class="cov8" title="1">if err := requestPacket.assert(ber.ClassUniversal, ber.TypePrimitive, withTag(ber.TagInteger), withAssertChild(childSizeLimit)); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: missing/invalid size limit: %w", op, ErrInvalidParameter)
        }</span>
        <span class="cov8" title="1">if searchFor.sizeLimit, ok = requestPacket.Children[childSizeLimit].Value.(int64); !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: size limit is not an int64", op)
        }</span>

        // time limit
        <span class="cov8" title="1">if err := requestPacket.assert(ber.ClassUniversal, ber.TypePrimitive, withTag(ber.TagInteger), withAssertChild(childTimeLimit)); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: missing/invalid time limit: %w", op, ErrInvalidParameter)
        }</span>
        <span class="cov8" title="1">if searchFor.timeLimit, ok = requestPacket.Children[childTimeLimit].Value.(int64); !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: time limit is not an int64", op)
        }</span>

        // types only
        <span class="cov8" title="1">if err := requestPacket.assert(ber.ClassUniversal, ber.TypePrimitive, withTag(ber.TagBoolean), withAssertChild(childTypesOnly)); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: missing/invalid types only: %w", op, ErrInvalidParameter)
        }</span>
        <span class="cov8" title="1">if searchFor.typesOnly, ok = requestPacket.Children[childTypesOnly].Value.(bool); !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: types only is not a bool", op)
        }</span>

        <span class="cov8" title="1">if len(requestPacket.Children) &lt; childFilter+1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: missing filter: %w", op, ErrInvalidParameter)
        }</span>

        <span class="cov8" title="1">filter, err := ldap.DecompileFilter(requestPacket.Children[childFilter])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: unable to decompile filter: %w", op, err)
        }</span>
        <span class="cov8" title="1">searchFor.filter = filter

        // check for attributes packet
        if len(requestPacket.Children) &lt; childAttributes+1 </span><span class="cov0" title="0">{
                return &amp;searchFor, nil // there's none, so just return
        }</span>
        <span class="cov8" title="1">if err := requestPacket.assert(ber.ClassUniversal, ber.TypeConstructed, withTag(ber.TagSequence), withAssertChild(childAttributes)); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: invalid attributes: %w", op, err)
        }</span>
        <span class="cov8" title="1">attributesPacket := packet{
                Packet: requestPacket.Children[childAttributes],
        }
        searchFor.attributes = make([]string, 0, len(attributesPacket.Children))
        for idx, attribute := range attributesPacket.Children </span><span class="cov8" title="1">{
                if err := attributesPacket.assert(ber.ClassUniversal, ber.TypePrimitive, withTag(ber.TagOctetString), withAssertChild(idx)); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%s: invalid attribute child packet: %w", op, err)
                }</span>
                <span class="cov8" title="1">searchFor.attributes = append(searchFor.attributes, attribute.Data.String())</span>
        }

        <span class="cov8" title="1">controlPacket, err := p.controlPacket()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: %w", op, err)
        }</span>
        <span class="cov8" title="1">if controlPacket != nil </span><span class="cov8" title="1">{
                searchFor.controls = make([]Control, 0, len(controlPacket.Children))
                for _, c := range controlPacket.Children </span><span class="cov8" title="1">{
                        ctrl, err := decodeControl(c)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("%s: %w", op, err)
                        }</span>
                        <span class="cov8" title="1">searchFor.controls = append(searchFor.controls, ctrl)</span>
                }
        }

        <span class="cov8" title="1">return &amp;searchFor, nil</span>
}

func (p *packet) assert(cl ber.Class, ty ber.Type, opt ...Option) error <span class="cov8" title="1">{
        const op = "gldap.assert"
        opts := getMessageOpts(opt...)

        if opts.withLenChildren != nil </span><span class="cov0" title="0">{
                if len(p.Children) != *opts.withLenChildren </span><span class="cov0" title="0">{
                        return fmt.Errorf("%s: not the correct number of children packets, expected %d but got %d", op, *opts.withLenChildren, len(p.Children))
                }</span>
        }
        <span class="cov8" title="1">if opts.withMinChildren != nil </span><span class="cov8" title="1">{
                if len(p.Children) &lt; *opts.withMinChildren </span><span class="cov8" title="1">{
                        return fmt.Errorf("%s: not enough children packets, expected %d but got %d", op, *opts.withMinChildren, len(p.Children))
                }</span>
        }

        <span class="cov8" title="1">chkPacket := p.Packet
        if opts.withAssertChild != nil </span><span class="cov8" title="1">{
                if len(p.Children) &lt; *opts.withAssertChild+1 </span><span class="cov8" title="1">{
                        return fmt.Errorf("%s: missing asserted child %d, but there are only %d", op, *opts.withAssertChild, len(p.Children))
                }</span>
                <span class="cov8" title="1">chkPacket = p.Packet.Children[*opts.withAssertChild]</span>
        }

        <span class="cov8" title="1">if chkPacket.ClassType != cl </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: incorrect class, expected %v but got %v", op, cl, chkPacket.ClassType)
        }</span>
        <span class="cov8" title="1">if chkPacket.TagType != ty </span><span class="cov8" title="1">{
                return fmt.Errorf("%s: incorrect type, expected %v but got %v", op, ty, chkPacket.TagType)
        }</span>
        <span class="cov8" title="1">if opts.withTag != nil &amp;&amp; chkPacket.Tag != *opts.withTag </span><span class="cov8" title="1">{
                return fmt.Errorf("%s: incorrect tag, expected %v but got %v", op, *opts.withTag, chkPacket.Tag)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (p *packet) assertApplicationRequest() error <span class="cov8" title="1">{
        const (
                op = "gldap.(packet).assertApplicationRequest"

                childApplicationRequest = 1
        )
        if len(p.Children) &lt; childApplicationRequest+1 </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: missing asserted application request child, but there are only %d", op, len(p.Children))
        }</span>
        <span class="cov8" title="1">chkPacket := p.Packet.Children[childApplicationRequest]

        if chkPacket.ClassType != ber.ClassApplication </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: incorrect class, expected %v (ber.ClassApplication) but got %v", op, ber.ClassApplication, chkPacket.ClassType)
        }</span>
        <span class="cov8" title="1">switch chkPacket.TagType </span>{
        case ber.TypePrimitive:<span class="cov8" title="1">
                if chkPacket.Tag != ApplicationDelRequest &amp;&amp; chkPacket.Tag != ApplicationUnbindRequest </span><span class="cov0" title="0">{
                        return fmt.Errorf("%s: incorrect type, primitive %q must be a delete request %q or an unbind request %q, but got %q", op, ber.TypePrimitive, ApplicationDelRequest, ApplicationUnbindRequest, chkPacket.Tag)
                }</span>
        case ber.TypeConstructed:<span class="cov8" title="1"></span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("%s: incorrect type, expected ber.TypeConstructed %q but got %v", op, ber.TypeConstructed, chkPacket.TagType)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (p *packet) debug() <span class="cov0" title="0">{
        testLogger := hclog.New(&amp;hclog.LoggerOptions{
                Name:  "debug-logger",
                Level: hclog.Debug,
        })
        p.Log(testLogger.StandardWriter(&amp;hclog.StandardLoggerOptions{}), 0, false)
}</span>

// Log will pretty print log a packet
func (p *packet) Log(out io.Writer, indent int, printBytes bool) <span class="cov8" title="1">{
        indentStr := ""

        for len(indentStr) != indent </span><span class="cov8" title="1">{
                indentStr += " "
        }</span>

        <span class="cov8" title="1">classStr := ber.ClassMap[p.ClassType]

        tagtypeStr := ber.TypeMap[p.TagType]

        tagStr := fmt.Sprintf("0x%02X", p.Tag)

        if p.ClassType == ber.ClassUniversal </span><span class="cov8" title="1">{
                tagStr = tagMap[p.Tag]
        }</span>

        <span class="cov8" title="1">value := fmt.Sprint(p.Value)
        description := ""

        if p.Description != "" </span><span class="cov8" title="1">{
                description = p.Description + ": "
        }</span>

        <span class="cov8" title="1">fmt.Fprintf(out, "%s%s(%s, %s, %s) Len=%d %q\n", indentStr, description, classStr, tagtypeStr, tagStr, p.Data.Len(), value)

        if printBytes </span><span class="cov0" title="0">{
                ber.PrintBytes(out, p.Bytes(), indentStr)
        }</span>

        <span class="cov8" title="1">for _, child := range p.Children </span><span class="cov8" title="1">{
                childPacket := packet{Packet: child}
                childPacket.Log(out, indent+1, printBytes)
        }</span>
}

func (p *packet) deleteParameters() (string, []Control, error) <span class="cov8" title="1">{
        const op = "gldap.(packet).deleteDN"

        requestPacket, err := p.requestPacket()
        if err != nil </span><span class="cov0" title="0">{
                return "", nil, fmt.Errorf("%s: %w", op, err)
        }</span>
        <span class="cov8" title="1">if requestPacket.Packet.Tag != ApplicationDelRequest </span><span class="cov0" title="0">{
                return "", nil, fmt.Errorf("%s: not a delete request, expected tag %d and got %d: %w", op, ApplicationDelRequest, requestPacket.Tag, ErrInvalidParameter)
        }</span>
        <span class="cov8" title="1">dn := requestPacket.Data.String()

        controlPacket, err := p.controlPacket()
        if err != nil </span><span class="cov0" title="0">{
                return "", nil, fmt.Errorf("%s: %w", op, err)
        }</span>
        <span class="cov8" title="1">var controls []Control
        if controlPacket != nil </span><span class="cov8" title="1">{
                controls = make([]Control, 0, len(controlPacket.Children))
                for _, c := range controlPacket.Children </span><span class="cov8" title="1">{
                        ctrl, err := decodeControl(c)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", nil, fmt.Errorf("%s: %w", op, err)
                        }</span>
                        <span class="cov8" title="1">controls = append(controls, ctrl)</span>
                }
        }
        <span class="cov8" title="1">return dn, controls, nil</span>
}

var tagMap = map[ber.Tag]string{
        ber.TagEOC:              "EOC (End-of-Content)",
        ber.TagBoolean:          "Boolean",
        ber.TagInteger:          "Integer",
        ber.TagBitString:        "Bit String",
        ber.TagOctetString:      "Octet String",
        ber.TagNULL:             "NULL",
        ber.TagObjectIdentifier: "Object Identifier",
        ber.TagObjectDescriptor: "Object Descriptor",
        ber.TagExternal:         "External",
        ber.TagRealFloat:        "Real (float)",
        ber.TagEnumerated:       "Enumerated",
        ber.TagEmbeddedPDV:      "Embedded PDV",
        ber.TagUTF8String:       "UTF8 String",
        ber.TagRelativeOID:      "Relative-OID",
        ber.TagSequence:         "Sequence and Sequence of",
        ber.TagSet:              "Set and Set OF",
        ber.TagNumericString:    "Numeric String",
        ber.TagPrintableString:  "Printable String",
        ber.TagT61String:        "T61 String",
        ber.TagVideotexString:   "Videotex String",
        ber.TagIA5String:        "IA5 String",
        ber.TagUTCTime:          "UTC Time",
        ber.TagGeneralizedTime:  "Generalized Time",
        ber.TagGraphicString:    "Graphic String",
        ber.TagVisibleString:    "Visible String",
        ber.TagGeneralString:    "General String",
        ber.TagUniversalString:  "Universal String",
        ber.TagCharacterString:  "Character String",
        ber.TagBMPString:        "BMP String",
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package gldap

import (
        "crypto/tls"
        "errors"
        "fmt"

        ber "github.com/go-asn1-ber/asn1-ber"
)

// ExtendedOperationName is an extended operation request/response name
type ExtendedOperationName string

// Extended operation response/request names
const (
        ExtendedOperationDisconnection   ExtendedOperationName = "1.3.6.1.4.1.1466.2003"
        ExtendedOperationCancel          ExtendedOperationName = "1.3.6.1.1.8"
        ExtendedOperationStartTLS        ExtendedOperationName = "1.3.6.1.4.1.1466.20037"
        ExtendedOperationWhoAmI          ExtendedOperationName = "1.3.6.1.4.1.4203.1.11.3"
        ExtendedOperationGetConnectionID ExtendedOperationName = "1.3.6.1.4.1.26027.1.6.2"
        ExtendedOperationPasswordModify  ExtendedOperationName = "1.3.6.1.4.1.4203.1.11.1"
        ExtendedOperationUnknown         ExtendedOperationName = "Unknown"
)

// Request represents an ldap request
type Request struct {
        // ID is the request number for a specific connection.  Every connection has
        // its own request counter which starts at 1.
        ID int

        // conn is needed this for cancellation among other things.
        conn         *conn
        message      Message
        routeOp      routeOperation
        extendedName ExtendedOperationName
}

func newRequest(id int, c *conn, p *packet) (*Request, error) <span class="cov8" title="1">{
        const op = "gldap.newRequest"
        if c == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%s: missing connection: %w", op, ErrInvalidParameter)
        }</span>
        <span class="cov8" title="1">if p == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%s: missing packet: %w", op, ErrInvalidParameter)
        }</span>

        <span class="cov8" title="1">m, err := newMessage(p)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%s: unable to build message for request %d: %w", op, id, err)
        }</span>
        <span class="cov8" title="1">var extendedName ExtendedOperationName
        var routeOp routeOperation
        switch v := m.(type) </span>{
        case *SimpleBindMessage:<span class="cov8" title="1">
                routeOp = bindRouteOperation</span>
        case *SearchMessage:<span class="cov8" title="1">
                routeOp = searchRouteOperation</span>
        case *ExtendedOperationMessage:<span class="cov8" title="1">
                routeOp = extendedRouteOperation
                extendedName = v.Name</span>
        case *ModifyMessage:<span class="cov8" title="1">
                routeOp = modifyRouteOperation</span>
        case *AddMessage:<span class="cov8" title="1">
                routeOp = addRouteOperation</span>
        case *DeleteMessage:<span class="cov8" title="1">
                routeOp = deleteRouteOperation</span>
        case *UnbindMessage:<span class="cov8" title="1">
                routeOp = unbindRouteOperation</span>
        default:<span class="cov0" title="0">
                // this should be unreachable, since newMessage defaults to returning an
                // *ExtendedOperationMessage
                return nil, fmt.Errorf("%s: %v is an unsupported route operation: %w", op, v, ErrInternal)</span>
        }

        <span class="cov8" title="1">r := &amp;Request{
                ID:           id,
                conn:         c,
                message:      m,
                routeOp:      routeOp,
                extendedName: extendedName,
        }
        return r, nil</span>
}

// ConnectionID returns the request's connection ID which enables you to know
// "who" (i.e. which connection) made a request. Using the connection ID you
// can do things like ensure a connection performing a search operation has
// successfully authenticated (a.k.a. performed a successful bind operation).
func (r *Request) ConnectionID() int <span class="cov8" title="1">{
        return r.conn.connID
}</span>

// NewModifyResponse creates a modify response
// Supported options: WithResponseCode, WithDiagnosticMessage, WithMatchedDN
func (r *Request) NewModifyResponse(opt ...Option) *ModifyResponse <span class="cov8" title="1">{
        opts := getResponseOpts(opt...)
        return &amp;ModifyResponse{
                GeneralResponse: r.NewResponse(
                        WithApplicationCode(ApplicationModifyResponse),
                        WithResponseCode(*opts.withResponseCode),
                        WithDiagnosticMessage(opts.withDiagnosticMessage),
                        WithMatchedDN(opts.withMatchedDN),
                ),
        }
}</span>

// StartTLS will start a TLS connection using the Message's existing connection
func (r *Request) StartTLS(tlsconfig *tls.Config) error <span class="cov8" title="1">{
        const op = "gldap.(Message).StartTLS"
        if tlsconfig == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: missing tls configuration: %w", op, ErrInvalidParameter)
        }</span>
        <span class="cov8" title="1">tlsConn := tls.Server(r.conn.netConn, tlsconfig)
        if err := tlsConn.Handshake(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: handshake error: %w", op, err)
        }</span>
        <span class="cov8" title="1">if err := r.conn.initConn(tlsConn); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: %w", op, err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// NewResponse creates a general response (not necessarily to any specific
// request because you can set WithApplicationCode).
// Supported options: WithResponseCode, WithApplicationCode,
// WithDiagnosticMessage, WithMatchedDN
func (r *Request) NewResponse(opt ...Option) *GeneralResponse <span class="cov8" title="1">{
        const op = "gldap.NewResponse" // nolint:unused
        opts := getResponseOpts(opt...)
        if opts.withResponseCode == nil </span><span class="cov0" title="0">{
                opts.withResponseCode = intPtr(ResultUnwillingToPerform)
        }</span>
        <span class="cov8" title="1">if opts.withApplicationCode == nil </span><span class="cov8" title="1">{
                opts.withApplicationCode = intPtr(ApplicationExtendedResponse)
        }</span>
        <span class="cov8" title="1">return &amp;GeneralResponse{
                baseResponse: &amp;baseResponse{
                        messageID:   r.message.GetID(),
                        code:        int16(*opts.withResponseCode),
                        diagMessage: opts.withDiagnosticMessage,
                        matchedDN:   opts.withMatchedDN,
                },
                applicationCode: *opts.withApplicationCode,
        }</span>
}

// NewExtendedResponse creates a new extended response.
// Supported options: WithResponseCode
func (r *Request) NewExtendedResponse(opt ...Option) *ExtendedResponse <span class="cov8" title="1">{
        const op = "gldap.NewExtendedResponse" // nolint:unused
        opts := getResponseOpts(opt...)
        resp := &amp;ExtendedResponse{
                baseResponse: &amp;baseResponse{
                        messageID: r.message.GetID(),
                },
        }
        if opts.withResponseCode != nil </span><span class="cov8" title="1">{
                resp.code = int16(*opts.withResponseCode)
        }</span>
        <span class="cov8" title="1">return resp</span>
}

// NewBindResponse creates a new bind response.
// Supported options: WithResponseCode
func (r *Request) NewBindResponse(opt ...Option) *BindResponse <span class="cov8" title="1">{
        const op = "gldap.NewBindResponse" // nolint:unused
        opts := getResponseOpts(opt...)
        resp := &amp;BindResponse{
                baseResponse: &amp;baseResponse{
                        messageID: r.message.GetID(),
                },
        }
        if opts.withResponseCode != nil </span><span class="cov8" title="1">{
                resp.code = int16(*opts.withResponseCode)
        }</span>
        <span class="cov8" title="1">return resp</span>
}

// GetSimpleBindMessage retrieves the SimpleBindMessage from the request, which
// allows you handle the request based on the message attributes.
func (r *Request) GetSimpleBindMessage() (*SimpleBindMessage, error) <span class="cov8" title="1">{
        const op = "gldap.(Request).GetSimpleBindMessage"
        s, ok := r.message.(*SimpleBindMessage)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: %T not a simple bind request: %w", op, r.message, ErrInvalidParameter)
        }</span>
        <span class="cov8" title="1">return s, nil</span>
}

// NewSearchDoneResponse creates a new search done response.  If there are no
// results found, then set the response code by adding the option
// WithResponseCode(ResultNoSuchObject)
//
// Supported options: WithResponseCode
func (r *Request) NewSearchDoneResponse(opt ...Option) *SearchResponseDone <span class="cov8" title="1">{
        const op = "gldap.(Request).NewSearchDoneResponse" // nolint:unused
        opts := getResponseOpts(opt...)
        resp := &amp;SearchResponseDone{
                baseResponse: &amp;baseResponse{
                        messageID: r.message.GetID(),
                },
        }
        if opts.withResponseCode != nil </span><span class="cov8" title="1">{
                resp.code = int16(*opts.withResponseCode)
        }</span>
        <span class="cov8" title="1">return resp</span>
}

// GetSearchMessage retrieves the SearchMessage from the request, which
// allows you handle the request based on the message attributes.
func (r *Request) GetSearchMessage() (*SearchMessage, error) <span class="cov8" title="1">{
        const op = "gldap.(Request).GetSearchMessage"
        m, ok := r.message.(*SearchMessage)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: %T not a search request: %w", op, r.message, ErrInvalidParameter)
        }</span>
        <span class="cov8" title="1">return m, nil</span>
}

// NewSearchResponseEntry is a search response entry.
// Supported options: WithAttributes
func (r *Request) NewSearchResponseEntry(entryDN string, opt ...Option) *SearchResponseEntry <span class="cov8" title="1">{
        opts := getResponseOpts(opt...)
        newAttrs := make([]*EntryAttribute, 0, len(opts.withAttributes))
        for name, values := range opts.withAttributes </span><span class="cov0" title="0">{
                newAttrs = append(newAttrs, NewEntryAttribute(name, values))
        }</span>
        <span class="cov8" title="1">return &amp;SearchResponseEntry{
                baseResponse: &amp;baseResponse{
                        messageID: r.message.GetID(),
                },
                entry: Entry{
                        DN:         entryDN,
                        Attributes: newAttrs,
                },
        }</span>
}

// GetModifyMessage retrieves the ModifyMessage from the request, which
// allows you handle the request based on the message attributes.
func (r *Request) GetModifyMessage() (*ModifyMessage, error) <span class="cov8" title="1">{
        const op = "gldap.(Request).GetModifyMessage"
        m, ok := r.message.(*ModifyMessage)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: %T not a modify request: %w", op, r.message, ErrInvalidParameter)
        }</span>
        <span class="cov8" title="1">return m, nil</span>
}

// GetAddMessage retrieves the AddMessage from the request, which
// allows you handle the request based on the message attributes.
func (r *Request) GetAddMessage() (*AddMessage, error) <span class="cov8" title="1">{
        const op = "gldap.(Request).GetAddMessage"
        m, ok := r.message.(*AddMessage)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: %T not a add request: %w", op, r.message, ErrInvalidParameter)
        }</span>
        <span class="cov8" title="1">return m, nil</span>
}

// GetDeleteMessage retrieves the DeleteMessage from the request, which
// allows you handle the request based on the message attributes.
func (r *Request) GetDeleteMessage() (*DeleteMessage, error) <span class="cov8" title="1">{
        const op = "gldap.(Request).GetDeleteMessage"
        m, ok := r.message.(*DeleteMessage)
        if !ok </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%s: %T not a delete request: %w", op, r.message, ErrInvalidParameter)
        }</span>
        <span class="cov8" title="1">return m, nil</span>
}

// GetUnbindMessage retrieves the UnbindMessage from the request, which
// allows you handle the request based on the message attributes.
func (r *Request) GetUnbindMessage() (*UnbindMessage, error) <span class="cov8" title="1">{
        const op = "gldap.(Request).GetUnbindMessage"
        m, ok := r.message.(*UnbindMessage)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: %T not an unbind request: %w", op, r.message, ErrInvalidParameter)
        }</span>
        <span class="cov8" title="1">return m, nil</span>
}

// ConvertString will convert an ASN1 BER Octet string into a "native" go
// string.  Support ber string encoding types: OctetString, GeneralString and
// all other types will return an error.
func ConvertString(octetString ...string) ([]string, error) <span class="cov8" title="1">{
        const (
                op             = "gldap.ConvertOctetString"
                berTagIdx      = 0
                startOfDataIdx = 1
        )

        converted := make([]string, 0, len(octetString))

        for _, s := range octetString </span><span class="cov8" title="1">{
                data := []byte(s)

                switch </span>{
                case
                        ber.Tag(data[berTagIdx]) == ber.TagOctetString,
                        ber.Tag(data[berTagIdx]) == ber.TagGeneralString:<span class="cov8" title="1">
                        _, strDataLen, err := readLength(data[startOfDataIdx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">converted = append(converted, string(data[(startOfDataIdx+strDataLen):]))</span>

                default:<span class="cov8" title="1">
                        return nil, fmt.Errorf("%s: unsupported ber encoding type %s: %w", op, string(data[berTagIdx]), ErrInvalidParameter)</span>
                }
        }

        <span class="cov8" title="1">return converted, nil</span>
}

// readLength(...)
// jimlambrt: 2/2023
// copied directly from github.com/go-asn1-ber/asn1-ber@v1.5.4/length.go
// it has an MIT license: https://github.com/go-asn1-ber/asn1-ber/blob/master/LICENSE
func readLength(bytes []byte) (length int, read int, err error) <span class="cov8" title="1">{
        // length byte
        b := bytes[0]
        read++

        switch </span>{
        case b == 0xFF:<span class="cov0" title="0">
                // Invalid 0xFF (x.600, 8.1.3.5.c)
                return 0, read, errors.New("invalid length byte 0xff")</span>

        case b == ber.LengthLongFormBitmask:<span class="cov0" title="0">
                // Indefinite form, we have to decode packets until we encounter an EOC packet (x.600, 8.1.3.6)
                length = ber.LengthIndefinite</span>

        case b&amp;ber.LengthLongFormBitmask == 0:<span class="cov8" title="1">
                // Short definite form, extract the length from the bottom 7 bits (x.600, 8.1.3.4)
                length = int(b) &amp; ber.LengthValueBitmask</span>

        case b&amp;ber.LengthLongFormBitmask != 0:<span class="cov0" title="0">
                // Long definite form, extract the number of length bytes to follow from the bottom 7 bits (x.600, 8.1.3.5.b)
                lengthBytes := int(b) &amp; ber.LengthValueBitmask
                // Protect against overflow
                // TODO: support big int length?
                if lengthBytes &gt; 8 </span><span class="cov0" title="0">{
                        return 0, read, errors.New("long-form length overflow")
                }</span>

                // Accumulate into a 64-bit variable
                <span class="cov0" title="0">var length64 int64
                for i := 0; i &lt; lengthBytes; i++ </span><span class="cov0" title="0">{
                        b = bytes[read]
                        read++

                        // x.600, 8.1.3.5
                        length64 &lt;&lt;= 8
                        length64 |= int64(b)
                }</span>

                // Cast to a platform-specific integer
                <span class="cov0" title="0">length = int(length64)
                // Ensure we didn't overflow
                if int64(length) != length64 </span><span class="cov0" title="0">{
                        return 0, read, errors.New("long-form length overflow")
                }</span>

        default:<span class="cov0" title="0">
                return 0, read, errors.New("invalid length byte")</span>
        }

        <span class="cov8" title="1">return length, read, nil</span>
}

func intPtr(i int) *int <span class="cov8" title="1">{
        return &amp;i
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package gldap

import (
        "bufio"
        "fmt"
        "sync"

        ber "github.com/go-asn1-ber/asn1-ber"
        "github.com/hashicorp/go-hclog"
)

// ResponseWriter is an ldap request response writer which is used by a
// HanderFunc to write responses to client requests.
type ResponseWriter struct {
        writerMu  *sync.Mutex // a shared lock across all requests to prevent data races when writing
        writer    *bufio.Writer
        logger    hclog.Logger
        connID    int
        requestID int
}

func newResponseWriter(w *bufio.Writer, lock *sync.Mutex, logger hclog.Logger, connID, requestID int) (*ResponseWriter, error) <span class="cov8" title="1">{
        const op = "gldap.NewResponseWriter"
        if w == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%s: missing writer: %w", op, ErrInvalidParameter)
        }</span>
        <span class="cov8" title="1">if lock == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%s: missing writer lock: %w", op, ErrInvalidParameter)
        }</span>
        <span class="cov8" title="1">if logger == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%s: missing logger: %w", op, ErrInvalidParameter)
        }</span>
        <span class="cov8" title="1">if connID == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%s: missing conn ID: %w", op, ErrInvalidParameter)
        }</span>
        <span class="cov8" title="1">if requestID == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%s: missing request ID: %w", op, ErrInvalidParameter)
        }</span>
        <span class="cov8" title="1">return &amp;ResponseWriter{
                writerMu:  lock,
                writer:    w,
                logger:    logger,
                connID:    connID,
                requestID: requestID,
        }, nil</span>
}

// Write will write the response to the client
func (rw *ResponseWriter) Write(r Response) error <span class="cov8" title="1">{
        const op = "gldap.(ResponseWriter).Write"
        if r == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%s: missing response: %w", op, ErrInvalidParameter)
        }</span>
        <span class="cov8" title="1">p := r.packet()
        if rw.logger.IsDebug() </span><span class="cov8" title="1">{
                rw.logger.Debug("response write", "op", op, "conn", rw.connID, "requestID", rw.requestID)
                p.Log(rw.logger.StandardWriter(&amp;hclog.StandardLoggerOptions{}), 0, false)
        }</span>
        <span class="cov8" title="1">rw.writerMu.Lock()
        defer rw.writerMu.Unlock()
        if _, err := rw.writer.Write(r.packet().Bytes()); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: unable to write response: %w", op, err)
        }</span>
        <span class="cov8" title="1">if err := rw.writer.Flush(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: unable to flush write: %w", op, err)
        }</span>
        <span class="cov8" title="1">rw.logger.Debug("finished writing", "op", op, "conn", rw.connID, "requestID", rw.requestID)
        return nil</span>
}

func beginResponse(messageID int64) *ber.Packet <span class="cov8" title="1">{
        const op = "gldap.beginResponse" // nolint:unused
        p := ber.Encode(ber.ClassUniversal, ber.TypeConstructed, ber.TagSequence, nil, "LDAP Response")
        p.AppendChild(ber.NewInteger(ber.ClassUniversal, ber.TypePrimitive, ber.TagInteger, messageID, "MessageID"))
        return p
}</span>

func addOptionalResponseChildren(bindResponse *ber.Packet, opt ...Option) <span class="cov8" title="1">{
        const op = "gldap.addOptionalResponseChildren" // nolint:unused
        opts := getResponseOpts(opt...)
        bindResponse.AppendChild(ber.NewString(ber.ClassUniversal, ber.TypePrimitive, ber.TagOctetString, opts.withMatchedDN, "matchedDN"))
        bindResponse.AppendChild(ber.NewString(ber.ClassUniversal, ber.TypePrimitive, ber.TagOctetString, opts.withDiagnosticMessage, "diagnosticMessage"))
}</span>

// Response represents a response to an ldap request
type Response interface {
        packet() *packet
}

type baseResponse struct {
        messageID   int64
        code        int16
        diagMessage string
        matchedDN   string
}

// SetResultCode the result code for a response.
func (l *baseResponse) SetResultCode(code int) <span class="cov8" title="1">{
        l.code = int16(code)
}</span>

// SetDiagnosticMessage sets the optional diagnostic message for a response.
func (l *baseResponse) SetDiagnosticMessage(msg string) <span class="cov8" title="1">{
        l.diagMessage = msg
}</span>

// SetMatchedDN sets the optional matched DN for a response.
func (l *baseResponse) SetMatchedDN(dn string) <span class="cov8" title="1">{
        l.matchedDN = dn
}</span>

// ExtendedResponse represents a response to an extended operation request
type ExtendedResponse struct {
        *baseResponse
        name ExtendedOperationName
}

// SetResponseName will set the response name for the extended operation response.
func (r *ExtendedResponse) SetResponseName(n ExtendedOperationName) <span class="cov8" title="1">{
        r.name = n
}</span>

func (r *ExtendedResponse) packet() *packet <span class="cov8" title="1">{
        replyPacket := beginResponse(r.messageID)

        // a new packet for the bind response
        resultPacket := ber.Encode(ber.ClassApplication, ber.TypeConstructed, ber.Tag(ApplicationExtendedResponse), nil, ApplicationCodeMap[ApplicationExtendedResponse])
        // append the result code to the bind response packet
        resultPacket.AppendChild(ber.NewInteger(ber.ClassUniversal, ber.TypePrimitive, ber.TagEnumerated, r.code, ResultCodeMap[uint16(r.code)]))

        // Add optional diagnostic message and matched DN
        addOptionalResponseChildren(resultPacket, WithDiagnosticMessage(r.diagMessage), WithMatchedDN(r.matchedDN))

        replyPacket.AppendChild(resultPacket)
        return &amp;packet{Packet: replyPacket}
}</span>

// BindResponse represents the response to a bind request
type BindResponse struct {
        *baseResponse
        controls []Control
}

// SetControls for bind response
func (r *BindResponse) SetControls(controls ...Control) <span class="cov8" title="1">{
        r.controls = controls
}</span>

func (r *BindResponse) packet() *packet <span class="cov8" title="1">{
        replyPacket := beginResponse(r.messageID)

        // a new packet for the bind response
        resultPacket := ber.Encode(ber.ClassApplication, ber.TypeConstructed, ber.Tag(ApplicationBindResponse), nil, ApplicationCodeMap[ApplicationBindResponse])
        // append the result code to the bind response packet
        resultPacket.AppendChild(ber.NewInteger(ber.ClassUniversal, ber.TypePrimitive, ber.TagEnumerated, r.code, ResultCodeMap[uint16(r.code)]))

        // Add optional diagnostic message and matched DN
        addOptionalResponseChildren(resultPacket, WithDiagnosticMessage(r.diagMessage), WithMatchedDN(r.matchedDN))

        replyPacket.AppendChild(resultPacket)
        if len(r.controls) &gt; 0 </span><span class="cov8" title="1">{
                replyPacket.AppendChild(encodeControls(r.controls))
        }</span>

        <span class="cov8" title="1">return &amp;packet{Packet: replyPacket}</span>
}

// GeneralResponse represents a general response (non-specific to a request).
type GeneralResponse struct {
        *baseResponse
        applicationCode int
}

func (r *GeneralResponse) packet() *packet <span class="cov8" title="1">{
        const op = "gldap.(GeneralResponse).packet" // nolint:unused
        replyPacket := beginResponse(r.messageID)

        // a new packet for the bind response
        resultPacket := ber.Encode(ber.ClassApplication, ber.TypeConstructed, ber.Tag(r.applicationCode), nil, ApplicationCodeMap[uint8(r.applicationCode)])
        // append the result code to the bind response packet
        resultPacket.AppendChild(ber.NewInteger(ber.ClassUniversal, ber.TypePrimitive, ber.TagEnumerated, r.code, ResultCodeMap[uint16(r.code)]))

        // Add optional diagnostic message and matched DN
        addOptionalResponseChildren(resultPacket, WithDiagnosticMessage(r.diagMessage), WithMatchedDN(r.matchedDN))

        replyPacket.AppendChild(resultPacket)
        return &amp;packet{Packet: replyPacket}
}</span>

// SearchResponseDone represents that handling a search requests is done.
type SearchResponseDone struct {
        *baseResponse
        controls []Control
}

// SetControls for the search response
func (r *SearchResponseDone) SetControls(controls ...Control) <span class="cov8" title="1">{
        r.controls = controls
}</span>

func (r *SearchResponseDone) packet() *packet <span class="cov8" title="1">{
        const op = "gldap.(SearchDoneResponse).packet" // nolint:unused
        replyPacket := beginResponse(r.messageID)

        resultPacket := ber.Encode(ber.ClassApplication, ber.TypeConstructed, ApplicationSearchResultDone, nil, ApplicationCodeMap[ApplicationSearchResultDone])
        resultPacket.AppendChild(ber.NewInteger(ber.ClassUniversal, ber.TypePrimitive, ber.TagEnumerated, r.code, ResultCodeMap[uint16(r.code)]))

        // Add optional diagnostic message and matched DN
        addOptionalResponseChildren(resultPacket, WithDiagnosticMessage(r.diagMessage), WithMatchedDN(r.matchedDN))

        replyPacket.AppendChild(resultPacket)
        if len(r.controls) &gt; 0 </span><span class="cov8" title="1">{
                replyPacket.AppendChild(encodeControls(r.controls))
        }</span>
        <span class="cov8" title="1">return &amp;packet{Packet: replyPacket}</span>
}

// SearchResponseEntry is an ldap entry that's part of search response.
type SearchResponseEntry struct {
        *baseResponse
        entry Entry
}

// AddAttribute will an attributes to the response entry
func (r *SearchResponseEntry) AddAttribute(name string, values []string) <span class="cov8" title="1">{
        r.entry.Attributes = append(r.entry.Attributes, NewEntryAttribute(name, values))
}</span>

func (r *SearchResponseEntry) packet() *packet <span class="cov8" title="1">{
        const op = "gldap.(SearchEntryResponse).packet" // nolint:unused
        replyPacket := beginResponse(r.messageID)

        resultPacket := ber.Encode(ber.ClassApplication, ber.TypeConstructed, ApplicationSearchResultEntry, nil, ApplicationCodeMap[ApplicationSearchResultEntry])
        resultPacket.AppendChild(ber.NewString(ber.ClassUniversal, ber.TypePrimitive, ber.TagOctetString, r.entry.DN, "DN"))
        attributesPacket := ber.Encode(ber.ClassUniversal, ber.TypeConstructed, ber.TagSequence, nil, "Attributes")
        for _, a := range r.entry.Attributes </span><span class="cov8" title="1">{
                attributesPacket.AppendChild(a.encode())
        }</span>
        <span class="cov8" title="1">resultPacket.AppendChild(attributesPacket)

        // Add optional diagnostic message and matched DN
        addOptionalResponseChildren(resultPacket, WithDiagnosticMessage(r.diagMessage), WithMatchedDN(r.matchedDN))

        replyPacket.AppendChild(resultPacket)
        return &amp;packet{Packet: replyPacket}</span>
}

// ModifyResponse is a response to a modify request.
type ModifyResponse struct {
        *GeneralResponse
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package gldap

type responseOptions struct {
        withDiagnosticMessage string
        withMatchedDN         string
        withResponseCode      *int
        withApplicationCode   *int
        withAttributes        map[string][]string
}

func responseDefaults() responseOptions <span class="cov8" title="1">{
        return responseOptions{
                withMatchedDN:         "Unused",
                withDiagnosticMessage: "Unused",
        }
}</span>

func getResponseOpts(opt ...Option) responseOptions <span class="cov8" title="1">{
        opts := responseDefaults()
        applyOpts(&amp;opts, opt...)
        return opts
}</span>

// WithDiagnosticMessage provides an optional diagnostic message for the
// response.
func WithDiagnosticMessage(msg string) Option <span class="cov8" title="1">{
        return func(o interface{}) </span><span class="cov8" title="1">{
                if o, ok := o.(*responseOptions); ok </span><span class="cov8" title="1">{
                        o.withDiagnosticMessage = msg
                }</span>
        }
}

// WithMatchedDN provides an optional match DN for the response.
func WithMatchedDN(dn string) Option <span class="cov8" title="1">{
        return func(o interface{}) </span><span class="cov8" title="1">{
                if o, ok := o.(*responseOptions); ok </span><span class="cov8" title="1">{
                        o.withMatchedDN = dn
                }</span>
        }
}

// WithResponseCode specifies the ldap response code.  For a list of valid codes
// see:
// https://github.com/go-ldap/ldap/blob/13008e4c5260d08625b65eb1f172ae909152b751/v3/error.go#L11
func WithResponseCode(code int) Option <span class="cov8" title="1">{
        return func(o interface{}) </span><span class="cov8" title="1">{
                if o, ok := o.(*responseOptions); ok </span><span class="cov8" title="1">{
                        o.withResponseCode = &amp;code
                }</span>
        }
}

// WithApplicationCode specifies the ldap application code.  For a list of valid codes
// for a list of supported application codes see:
// https://github.com/jimlambrt/gldap/blob/8f171b8eb659c76019719382c4daf519dd1281e6/codes.go#L159
func WithApplicationCode(applicationCode int) Option <span class="cov8" title="1">{
        return func(o interface{}) </span><span class="cov8" title="1">{
                if o, ok := o.(*responseOptions); ok </span><span class="cov8" title="1">{
                        o.withApplicationCode = &amp;applicationCode
                }</span>
        }
}

// WithAttributes specifies optional attributes for a response entry
func WithAttributes(attributes map[string][]string) Option <span class="cov8" title="1">{
        return func(o interface{}) </span><span class="cov8" title="1">{
                if o, ok := o.(*responseOptions); ok </span><span class="cov8" title="1">{
                        o.withAttributes = attributes
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package gldap

import (
        "strings"
)

// routeOperation represents the ldap operation for a route.
type routeOperation string

const (
        // undefinedRouteOperation is an undefined operation.
        undefinedRouteOperation routeOperation = "" // nolint:unused

        // bindRouteOperation is a route supporting the bind operation
        bindRouteOperation routeOperation = "bind"

        // searchRouteOperation is a route supporting the search operation
        searchRouteOperation routeOperation = "search"

        // extendedRouteOperation is a route supporting an extended operation
        extendedRouteOperation routeOperation = "extendedOperation"

        // modifyRouteOperation is a route supporting the modify operation
        modifyRouteOperation routeOperation = "modify"

        // addRouteOperation is a route supporting the add operation
        addRouteOperation routeOperation = "add"

        // deleteRouteOperation is a route supporting the delete operation
        deleteRouteOperation routeOperation = "delete"

        // unbindRouteOperation is a route supporting the unbind operation
        unbindRouteOperation routeOperation = "unbind"

        // defaultRouteOperation is a default route which is used when there are no routes
        // defined for a particular operation
        defaultRouteOperation routeOperation = "noRoute" // nolint:unused
)

// HandlerFunc defines a function for handling an LDAP request.
type HandlerFunc func(*ResponseWriter, *Request)

type route interface {
        match(req *Request) bool
        handler() HandlerFunc
        op() routeOperation
}

type baseRoute struct {
        h       HandlerFunc
        routeOp routeOperation
        label   string
}

func (r *baseRoute) handler() HandlerFunc <span class="cov8" title="1">{
        return r.h
}</span>

func (r *baseRoute) op() routeOperation <span class="cov8" title="1">{
        return r.routeOp
}</span>

func (r *baseRoute) match(req *Request) bool <span class="cov8" title="1">{
        return false
}</span>

type searchRoute struct {
        *baseRoute
        basedn string
        filter string
        scope  Scope
}

type simpleBindRoute struct {
        *baseRoute
        authChoice AuthChoice
}

type unbindRoute struct {
        *baseRoute
}

type extendedRoute struct {
        *baseRoute
        extendedName ExtendedOperationName
}

type modifyRoute struct {
        *baseRoute
}

type addRoute struct {
        *baseRoute
}

type deleteRoute struct {
        *baseRoute
}

func (r *deleteRoute) match(req *Request) bool <span class="cov8" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if r.op() != req.routeOp </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if _, ok := req.message.(*DeleteMessage); !ok </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}

func (r *addRoute) match(req *Request) bool <span class="cov8" title="1">{
        if req == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if r.op() != req.routeOp </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if _, ok := req.message.(*AddMessage); !ok </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}

func (r *modifyRoute) match(req *Request) bool <span class="cov8" title="1">{
        if req == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if r.op() != req.routeOp </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if _, ok := req.message.(*ModifyMessage); !ok </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}

func (r *simpleBindRoute) match(req *Request) bool <span class="cov8" title="1">{
        if req == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if r.op() != req.routeOp </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if m, ok := req.message.(*SimpleBindMessage); ok </span><span class="cov8" title="1">{
                if r.authChoice != "" &amp;&amp; r.authChoice == m.AuthChoice </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func (r *extendedRoute) match(req *Request) bool <span class="cov8" title="1">{
        if req == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if r.op() != req.routeOp </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if r.extendedName != req.extendedName </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">_, ok := req.message.(*ExtendedOperationMessage)
        return ok</span>
}

func (r *searchRoute) match(req *Request) bool <span class="cov8" title="1">{
        if req == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if r.op() != req.routeOp </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">searchMsg, ok := req.message.(*SearchMessage)
        if !ok </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if r.basedn != "" &amp;&amp; !strings.EqualFold(searchMsg.BaseDN, r.basedn) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if r.filter != "" &amp;&amp; !strings.EqualFold(searchMsg.Filter, r.filter) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if r.scope != 0 &amp;&amp; searchMsg.Scope != r.scope </span><span class="cov8" title="1">{
                return false
        }</span>

        // if it didn't get eliminated by earlier request criteria, then it's a
        // match.
        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package gldap

type routeOptions struct {
        withLabel  string
        withBaseDN string
        withFilter string
        withScope  Scope
}

func routeDefaults() routeOptions <span class="cov8" title="1">{
        return routeOptions{}
}</span>

func getRouteOpts(opt ...Option) routeOptions <span class="cov8" title="1">{
        opts := routeDefaults()
        applyOpts(&amp;opts, opt...)
        return opts
}</span>

// WithLabel specifies an optional label for the route
func WithLabel(l string) Option <span class="cov8" title="1">{
        return func(o interface{}) </span><span class="cov8" title="1">{
                if o, ok := o.(*routeOptions); ok </span><span class="cov8" title="1">{
                        o.withLabel = l
                }</span>
        }
}

// WithBaseDN specifies an optional base DN to associate with a Search route
func WithBaseDN(dn string) Option <span class="cov8" title="1">{
        return func(o interface{}) </span><span class="cov8" title="1">{
                if o, ok := o.(*routeOptions); ok </span><span class="cov8" title="1">{
                        o.withBaseDN = dn
                }</span>
        }
}

// WithFilter specifies an optional filter to associate with a Search route
func WithFilter(filter string) Option <span class="cov8" title="1">{
        return func(o interface{}) </span><span class="cov8" title="1">{
                if o, ok := o.(*routeOptions); ok </span><span class="cov8" title="1">{
                        o.withFilter = filter
                }</span>
        }
}

// WithScope specifies and optional scope to associate with a Search route
func WithScope(s Scope) Option <span class="cov8" title="1">{
        return func(o interface{}) </span><span class="cov8" title="1">{
                if o, ok := o.(*routeOptions); ok </span><span class="cov8" title="1">{
                        o.withScope = s
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package gldap

import (
        "context"
        "crypto/tls"
        "fmt"
        "net"
        "strings"
        "sync"
        "time"

        "github.com/hashicorp/go-hclog"
)

// Server is an ldap server that you can add a mux (multiplexer) router to and
// then run it to accept and process requests.
type Server struct {
        mu             sync.RWMutex
        logger         hclog.Logger
        connWg         sync.WaitGroup
        listener       net.Listener
        listenerReady  bool
        router         *Mux
        tlsConfig      *tls.Config
        readTimeout    time.Duration
        writeTimeout   time.Duration
        onCloseHandler OnCloseHandler

        disablePanicRecovery bool
        shutdownCancel       context.CancelFunc
        shutdownCtx          context.Context
}

// NewServer creates a new ldap server
//
// Options supported:
// - WithLogger allows you pass a logger with whatever hclog.Level you wish including hclog.Off to turn off all logging
// - WithReadTimeout will set a read time out per connection
// - WithWriteTimeout will set a write time out per connection
// - WithOnClose will define a callback the server will call every time a connection is closed
func NewServer(opt ...Option) (*Server, error) <span class="cov8" title="1">{
        cancelCtx, cancel := context.WithCancel(context.Background())
        opts := getConfigOpts(opt...)

        if opts.withLogger == nil </span><span class="cov8" title="1">{
                opts.withLogger = hclog.New(&amp;hclog.LoggerOptions{
                        Name:  "Server-logger",
                        Level: hclog.Error,
                })
        }</span>

        <span class="cov8" title="1">return &amp;Server{
                router:               &amp;Mux{}, // TODO: a better default router
                logger:               opts.withLogger,
                shutdownCancel:       cancel,
                shutdownCtx:          cancelCtx,
                writeTimeout:         opts.withWriteTimeout,
                readTimeout:          opts.withReadTimeout,
                disablePanicRecovery: opts.withDisablePanicRecovery,
                onCloseHandler:       opts.withOnClose,
        }, nil</span>
}

// Run will run the server which will listen and serve requests.
//
// Options supported: WithTLSConfig
func (s *Server) Run(addr string, opt ...Option) error <span class="cov8" title="1">{
        const op = "gldap.(Server).Run"
        opts := getConfigOpts(opt...)

        var err error
        s.mu.Lock()
        s.listener, err = net.Listen("tcp", addr)
        s.listenerReady = true
        s.mu.Unlock()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: unable to listen to addr %s: %w", op, addr, err)
        }</span>
        <span class="cov8" title="1">if opts.withTLSConfig != nil </span><span class="cov8" title="1">{
                s.logger.Debug("setting up TLS listener", "op", op)
                s.tlsConfig = opts.withTLSConfig
                s.mu.Lock()
                s.listener = tls.NewListener(s.listener, s.tlsConfig)
                s.mu.Unlock()
        }</span>
        <span class="cov8" title="1">s.logger.Info("listening", "op", op, "addr", s.listener.Addr())

        connID := 0
        for </span><span class="cov8" title="1">{
                connID++
                select </span>{
                case &lt;-s.shutdownCtx.Done():<span class="cov0" title="0">
                        return nil</span>
                default:<span class="cov8" title="1"></span>
                        // need a default to fall through to rest of loop...
                }
                <span class="cov8" title="1">c, err := s.listener.Accept()
                if err != nil </span><span class="cov8" title="1">{
                        if strings.Contains(err.Error(), "use of closed network connection") </span><span class="cov8" title="1">{
                                s.logger.Debug("accept on closed conn")
                                return nil
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf("%s: error accepting conn: %w", op, err)</span>
                }
                <span class="cov8" title="1">s.logger.Debug("new connection accepted", "op", op, "conn", connID)
                conn, err := newConn(s.shutdownCtx, connID, c, s.logger, s.router)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("%s: unable to create in-memory conn: %w", op, err)
                }</span>
                <span class="cov8" title="1">localConnID := connID
                s.connWg.Add(1)
                go func() </span><span class="cov8" title="1">{
                        defer func() </span><span class="cov8" title="1">{
                                s.logger.Debug("connWg done", "op", op, "conn", localConnID)
                                s.connWg.Done()
                                err := conn.close()
                                if err != nil </span><span class="cov0" title="0">{
                                        s.logger.Error("error closing conn", "op", op, "conn", localConnID, "conn/req", "err", err)
                                        // we are intentionally not returning here; since we still
                                        // need to call the onCloseHandler if it's not nil
                                }</span>
                                <span class="cov8" title="1">if s.onCloseHandler != nil </span><span class="cov8" title="1">{
                                        s.onCloseHandler(localConnID)
                                }</span>
                        }()

                        <span class="cov8" title="1">if !s.disablePanicRecovery </span><span class="cov8" title="1">{
                                // catch and report panics - we don't want it to crash the server if
                                // handling a single conn causes a panic
                                defer func() </span><span class="cov8" title="1">{
                                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                                s.logger.Error("Caught panic while serving request", "op", op, "conn", localConnID, "conn/req", fmt.Sprintf("%+v: %+v", c, r))
                                        }</span>
                                }()
                        }
                        <span class="cov8" title="1">if s.readTimeout != 0 </span><span class="cov8" title="1">{
                                if err := c.SetReadDeadline(time.Now().Add(s.readTimeout)); err != nil </span><span class="cov0" title="0">{
                                        s.logger.Error("unable to set read deadline", "op", op, "err", err.Error())
                                        return
                                }</span>
                        }
                        <span class="cov8" title="1">if s.writeTimeout != 0 </span><span class="cov8" title="1">{
                                if err := c.SetWriteDeadline(time.Now().Add(s.writeTimeout)); err != nil </span><span class="cov0" title="0">{
                                        s.logger.Error("unable to set write deadline", "op", op, "err", err.Error())
                                        return
                                }</span>
                        }
                        <span class="cov8" title="1">if err := conn.serveRequests(); err != nil </span><span class="cov8" title="1">{
                                s.logger.Error("error handling conn", "op", op, "conn", localConnID, "err", err.Error())
                        }</span>
                }()
        }
}

// Ready will return true when the server is ready to accept connection
func (s *Server) Ready() bool <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.listenerReady
}</span>

// Stop a running ldap server
func (s *Server) Stop() error <span class="cov8" title="1">{
        const op = "gldap.(Server).Stop"
        s.mu.RLock()
        defer s.mu.RUnlock()

        s.logger.Debug("shutting down")
        if s.listener == nil &amp;&amp; s.shutdownCancel == nil </span><span class="cov8" title="1">{
                s.logger.Debug("nothing to do for shutdown")
                return nil
        }</span>

        <span class="cov8" title="1">if s.listener != nil </span><span class="cov8" title="1">{
                s.logger.Debug("closing listener")
                if err := s.listener.Close(); err != nil </span><span class="cov8" title="1">{
                        switch </span>{
                        case !strings.Contains(err.Error(), "use of closed network connection"):<span class="cov8" title="1">
                                return fmt.Errorf("%s: %w", op, err)</span>
                        default:<span class="cov8" title="1">
                                s.logger.Debug("listener already closed")</span>
                        }
                }
        }
        <span class="cov8" title="1">if s.shutdownCancel != nil </span><span class="cov8" title="1">{
                s.logger.Debug("shutdown cancel func")
                s.shutdownCancel()
        }</span>
        <span class="cov8" title="1">s.logger.Debug("waiting on connections to close")
        s.connWg.Wait()
        s.logger.Debug("stopped")
        return nil</span>
}

// Router sets the mux (multiplexer) router for matching inbound requests
// to handlers.
func (s *Server) Router(r *Mux) error <span class="cov8" title="1">{
        const op = "gldap.(Server).HandleRoutes"
        if r == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%s: missing router: %w", op, ErrInvalidParameter)
        }</span>
        <span class="cov8" title="1">s.mu.Lock()
        defer s.mu.Unlock()
        s.router = r
        return nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package gldap

import (
        "crypto/tls"
        "time"

        "github.com/hashicorp/go-hclog"
)

type configOptions struct {
        withTLSConfig            *tls.Config
        withLogger               hclog.Logger
        withReadTimeout          time.Duration
        withWriteTimeout         time.Duration
        withDisablePanicRecovery bool
        withOnClose              OnCloseHandler
}

func configDefaults() configOptions <span class="cov8" title="1">{
        return configOptions{}
}</span>

// getConfigOpts gets the defaults and applies the opt overrides passed
// in.
func getConfigOpts(opt ...Option) configOptions <span class="cov8" title="1">{
        opts := configDefaults()
        applyOpts(&amp;opts, opt...)
        return opts
}</span>

// WithLogger provides the optional logger.
func WithLogger(l hclog.Logger) Option <span class="cov8" title="1">{
        return func(o interface{}) </span><span class="cov8" title="1">{
                if o, ok := o.(*configOptions); ok </span><span class="cov8" title="1">{
                        o.withLogger = l
                }</span>
        }
}

// WithTLSConfig provides an optional tls.Config
func WithTLSConfig(tc *tls.Config) Option <span class="cov8" title="1">{
        return func(o interface{}) </span><span class="cov8" title="1">{
                switch v := o.(type) </span>{
                case *configOptions:<span class="cov8" title="1">
                        v.withTLSConfig = tc</span>
                }
        }
}

// WithReadTimeout will set a read time out per connection
func WithReadTimeout(d time.Duration) Option <span class="cov8" title="1">{
        return func(o interface{}) </span><span class="cov8" title="1">{
                if o, ok := o.(*configOptions); ok </span><span class="cov8" title="1">{
                        o.withReadTimeout = d
                }</span>
        }
}

// WithWriteTimeout will set a write timeout per connection
func WithWriteTimeout(d time.Duration) Option <span class="cov8" title="1">{
        return func(o interface{}) </span><span class="cov8" title="1">{
                if o, ok := o.(*configOptions); ok </span><span class="cov8" title="1">{
                        o.withWriteTimeout = d
                }</span>
        }
}

// WithDisablePanicRecovery will disable recovery from panics which occur when
// handling a request.  This is helpful for debugging since you'll get the
// panic's callstack.
func WithDisablePanicRecovery() Option <span class="cov8" title="1">{
        return func(o interface{}) </span><span class="cov8" title="1">{
                if o, ok := o.(*configOptions); ok </span><span class="cov8" title="1">{
                        o.withDisablePanicRecovery = true
                }</span>
        }
}

// OnCloseHandler defines a function for a "on close" callback handler.  See:
// NewServer(...) and WithOnClose(...) option for more information
type OnCloseHandler func(connectionID int)

// WithOnClose defines a OnCloseHandler that the server will use as a callback
// every time a connection to the server is closed.   This allows callers to
// clean up resources for closed connections (using their ID to determine which
// one to clean up)
func WithOnClose(handler OnCloseHandler) Option <span class="cov8" title="1">{
        return func(o interface{}) </span><span class="cov8" title="1">{
                if o, ok := o.(*configOptions); ok </span><span class="cov8" title="1">{
                        o.withOnClose = handler
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package gldap

import (
        "bytes"
        "encoding/binary"
        "fmt"
)

// SIDBytes creates a SID from the provided revision and identifierAuthority
func SIDBytes(revision uint8, identifierAuthority uint16) ([]byte, error) <span class="cov8" title="1">{
        const op = "gldap.SidBytes"
        var identifierAuthorityParts [3]uint16
        identifierAuthorityParts[2] = identifierAuthority

        subAuthorityCount := uint8(0)
        var writer bytes.Buffer
        if err := binary.Write(&amp;writer, binary.LittleEndian, uint8(revision)); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: unable to write revision: %w", op, err)
        }</span>
        <span class="cov8" title="1">if err := binary.Write(&amp;writer, binary.LittleEndian, subAuthorityCount); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: unable to write subauthority count: %w", op, err)
        }</span>
        <span class="cov8" title="1">if err := binary.Write(&amp;writer, binary.BigEndian, identifierAuthorityParts); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: unable to write authority parts: %w", op, err)
        }</span>
        <span class="cov8" title="1">return writer.Bytes(), nil</span>
}

// SIDBytesToString will convert SID bytes to a string
func SIDBytesToString(b []byte) (string, error) <span class="cov8" title="1">{
        const op = "gldap.sidBytesToString"
        reader := bytes.NewReader(b)

        var revision, subAuthorityCount uint8
        var identifierAuthorityParts [3]uint16

        if err := binary.Read(reader, binary.LittleEndian, &amp;revision); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%s: SID %#v convert failed reading Revision: %w", op, b, err)
        }</span>

        <span class="cov8" title="1">if err := binary.Read(reader, binary.LittleEndian, &amp;subAuthorityCount); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%s: SID %#v convert failed reading SubAuthorityCount: %w", op, b, err)
        }</span>

        <span class="cov8" title="1">if err := binary.Read(reader, binary.BigEndian, &amp;identifierAuthorityParts); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%s: SID %#v convert failed reading IdentifierAuthority: %w", op, b, err)
        }</span>
        <span class="cov8" title="1">identifierAuthority := (uint64(identifierAuthorityParts[0]) &lt;&lt; 32) + (uint64(identifierAuthorityParts[1]) &lt;&lt; 16) + uint64(identifierAuthorityParts[2])

        subAuthority := make([]uint32, subAuthorityCount)
        if err := binary.Read(reader, binary.LittleEndian, &amp;subAuthority); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%s: SID %#v convert failed reading SubAuthority: %w", op, b, err)
        }</span>

        <span class="cov8" title="1">result := fmt.Sprintf("S-%d-%d", revision, identifierAuthority)
        for _, subAuthorityPart := range subAuthority </span><span class="cov8" title="1">{
                result += fmt.Sprintf("-%d", subAuthorityPart)
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package testdirectory

import (
        "bytes"
        "crypto/tls"
        "crypto/x509"
        "encoding/pem"
        "fmt"
        "regexp"
        "strings"
        "sync"
        "time"

        "github.com/cenkalti/backoff"
        "github.com/go-ldap/ldap/v3"
        "github.com/hashicorp/go-hclog"
        "github.com/jimlambrt/gldap"
        "github.com/stretchr/testify/require"
        "golang.org/x/exp/slices"
)

const (
        // DefaultUserAttr is the "username" attribute of the entry's DN and is
        // typically either the cn in ActiveDirectory or uid in openLDAP  (default:
        // cn)
        DefaultUserAttr = "cn"

        // DefaultGroupAttr for the ClientConfig.GroupAttr
        DefaultGroupAttr = "cn"

        // DefaultUserDN defines a default base distinguished name to use when
        // searching for users for the Directory
        DefaultUserDN = "ou=people,dc=example,dc=org"

        // DefaultGroupDN defines a default base distinguished name to use when
        // searching for groups for the Directory
        DefaultGroupDN = "ou=groups,dc=example,dc=org"
)

// Directory is a local ldap directory that supports test ldap capabilities
// which makes writing tests much easier.
//
// It's important to remember that the Directory is stateful (see any of its
// receiver functions that begin with Set*)
//
// Once you started a Directory with Start(...), the following
// test ldap operations are supported:
//
//   - Bind
//   - StartTLS
//   - Search
//   - Modify
//   - Add
//
// Making requests to the Directory is facilitated by:
//   - Directory.Conn()                returns a *ldap.Conn connected to the Directory (honors WithMTLS options from start)
//   - Directory.Cert()                 returns the pem-encoded CA certificate used by the directory.
//   - Directory.Port()                 returns the port the directory is listening on.
//   - Directory.ClientCert()         returns a client cert for mtls
//   - Directory.ClientKey()         returns a client private key for mtls
type Directory struct {
        t      TestingT
        s      *gldap.Server
        logger hclog.Logger
        port   int
        host   string
        useTLS bool
        client *tls.Config
        server *tls.Config

        mu                 sync.Mutex
        users              []*gldap.Entry
        groups             []*gldap.Entry
        tokenGroups        map[string][]*gldap.Entry // string == SID
        allowAnonymousBind bool
        controls           []gldap.Control

        // userDN is the base distinguished name to use when searching for users
        userDN string
        // groupDN is the base distinguished name to use when searching for groups
        groupDN string
}

// Start creates and starts a running Directory ldap server.
// Support options: WithPort, WithMTLS, WithNoTLS, WithDefaults,
// WithLogger.
//
// The Directory will be shutdown when the test and all its
// subtests are compted via a registered function with t.Cleanup(...)
func Start(t TestingT, opt ...Option) *Directory <span class="cov8" title="1">{
        if v, ok := interface{}(t).(HelperT); ok </span><span class="cov8" title="1">{
                v.Helper()
        }</span>
        <span class="cov8" title="1">require := require.New(t)
        opts := getOpts(t, opt...)
        if opts.withPort == 0 </span><span class="cov8" title="1">{
                opts.withPort = FreePort(t)
        }</span>

        <span class="cov8" title="1">d := &amp;Directory{
                t:                  t,
                logger:             opts.withLogger,
                users:              opts.withDefaults.Users,
                groups:             opts.withDefaults.Groups,
                port:               opts.withPort,
                host:               opts.withHost,
                userDN:             opts.withDefaults.UserDN,
                groupDN:            opts.withDefaults.GroupDN,
                allowAnonymousBind: opts.withDefaults.AllowAnonymousBind,
        }

        var err error
        var srvOpts []gldap.Option
        if opts.withLogger != nil </span><span class="cov8" title="1">{
                srvOpts = append(srvOpts, gldap.WithLogger(opts.withLogger))
        }</span>
        <span class="cov8" title="1">if opts.withDisablePanicRecovery </span><span class="cov8" title="1">{
                srvOpts = append(srvOpts, gldap.WithDisablePanicRecovery())
        }</span>
        <span class="cov8" title="1">d.s, err = gldap.NewServer(srvOpts...)
        require.NoError(err)

        d.logger.Debug("base search DNs", "users", d.userDN, "groups", d.groupDN)

        mux, err := gldap.NewMux()
        require.NoError(err)
        require.NoError(mux.DefaultRoute(d.handleNotFound(t)))
        require.NoError(mux.Bind(d.handleBind(t)))
        require.NoError(mux.ExtendedOperation(d.handleStartTLS(t), gldap.ExtendedOperationStartTLS))
        require.NoError(mux.Search(d.handleSearchUsers(t), gldap.WithBaseDN(d.userDN), gldap.WithLabel("Search - Users")))
        require.NoError(mux.Search(d.handleSearchGroups(t), gldap.WithBaseDN(d.groupDN), gldap.WithLabel("Search - Groups")))
        require.NoError(mux.Search(d.handleSearchGeneric(t), gldap.WithLabel("Search - Generic")))
        require.NoError(mux.Modify(d.handleModify(t), gldap.WithLabel("Modify")))
        require.NoError(mux.Add(d.handleAdd(t), gldap.WithLabel("Add")))
        require.NoError(mux.Delete(d.handleDelete(t), gldap.WithLabel("Delete")))

        require.NoError(d.s.Router(mux))

        serverTLSConfig, clientTLSConfig := GetTLSConfig(t, opt...)
        d.client = clientTLSConfig
        d.server = serverTLSConfig

        var connOpts []gldap.Option
        if !opts.withNoTLS </span><span class="cov8" title="1">{
                d.useTLS = true
                connOpts = append(connOpts, gldap.WithTLSConfig(d.server))
                if opts.withMTLS </span><span class="cov8" title="1">{
                        d.logger.Debug("using mTLS")
                }</span> else<span class="cov8" title="1"> {
                        d.logger.Debug("using TLS")
                }</span>
        } else<span class="cov8" title="1"> {
                d.logger.Debug("not using TLS")
        }</span>
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                err := d.s.Run(fmt.Sprintf("%s:%d", opts.withHost, opts.withPort), connOpts...)
                require.NoError(err)
        }</span>()

        <span class="cov8" title="1">if v, ok := interface{}(t).(CleanupT); ok </span><span class="cov8" title="1">{
                v.Cleanup(func() </span><span class="cov8" title="1">{ _ = d.s.Stop() }</span>)
        }
        // need a bit of a pause to get the service up and running, otherwise we'll
        // get a connection error because the service isn't listening yet.
        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                time.Sleep(100 * time.Nanosecond)
                if d.s.Ready() </span><span class="cov8" title="1">{
                        break</span>
                }
        }
        <span class="cov8" title="1">return d</span>
}

// Stop will stop the Directory if it wasn't started with a *testing.T
// if it was started with *testing.T then Stop() is ignored.
func (d *Directory) Stop() <span class="cov8" title="1">{
        const op = "testdirectory.(Directory).Stop"
        if _, ok := interface{}(d.t).(CleanupT); !ok </span><span class="cov8" title="1">{
                err := d.s.Stop()
                if err != nil </span><span class="cov0" title="0">{
                        d.logger.Error("error stopping directory: %s", "op", op, "err", err)
                        return
                }</span>
        }
}

// handleBind is ONLY supporting simple authentication (no SASL here!)
func (d *Directory) handleBind(t TestingT) func(w *gldap.ResponseWriter, r *gldap.Request) <span class="cov8" title="1">{
        const op = "testdirectory.(Directory).handleBind"
        if v, ok := interface{}(t).(HelperT); ok </span><span class="cov8" title="1">{
                v.Helper()
        }</span>
        <span class="cov8" title="1">return func(w *gldap.ResponseWriter, r *gldap.Request) </span><span class="cov8" title="1">{
                d.logger.Debug(op)
                resp := r.NewBindResponse(gldap.WithResponseCode(gldap.ResultInvalidCredentials))
                defer func() </span><span class="cov8" title="1">{
                        _ = w.Write(resp)
                }</span>()
                <span class="cov8" title="1">m, err := r.GetSimpleBindMessage()
                if err != nil </span><span class="cov0" title="0">{
                        d.logger.Error("not a simple bind message", "op", op, "err", err)
                        return
                }</span>

                <span class="cov8" title="1">if m.AuthChoice != gldap.SimpleAuthChoice </span><span class="cov0" title="0">{
                        // if it's not a simple auth request, then the bind failed...
                        return
                }</span>
                <span class="cov8" title="1">if m.Password == "" &amp;&amp; d.allowAnonymousBind </span><span class="cov8" title="1">{
                        resp.SetResultCode(gldap.ResultSuccess)
                        return
                }</span>

                <span class="cov8" title="1">for _, u := range d.users </span><span class="cov8" title="1">{
                        d.logger.Debug("user", "u.DN", u.DN, "m.UserName", m.UserName)
                        if u.DN == m.UserName </span><span class="cov8" title="1">{
                                d.logger.Debug("found bind user", "op", op, "DN", u.DN)
                                values := u.GetAttributeValues("password")
                                if len(values) &gt; 0 &amp;&amp; string(m.Password) == values[0] </span><span class="cov8" title="1">{
                                        resp.SetResultCode(gldap.ResultSuccess)
                                        if d.controls != nil </span><span class="cov8" title="1">{
                                                d.mu.Lock()
                                                defer d.mu.Unlock()
                                                resp.SetControls(d.controls...)
                                        }</span>
                                        <span class="cov8" title="1">return</span>
                                }
                        }
                }
                // bind failed...
                <span class="cov8" title="1">return</span> //nolint:gosimple // (ignore redundant return)
        }
}

func (d *Directory) handleNotFound(t TestingT) func(w *gldap.ResponseWriter, r *gldap.Request) <span class="cov8" title="1">{
        const op = "testdirectory.(Directory).handleNotFound"
        if v, ok := interface{}(t).(HelperT); ok </span><span class="cov8" title="1">{
                v.Helper()
        }</span>
        <span class="cov8" title="1">return func(w *gldap.ResponseWriter, r *gldap.Request) </span><span class="cov0" title="0">{
                d.logger.Debug(op)
                resp := r.NewResponse(gldap.WithDiagnosticMessage("intentionally not handled"))
                _ = w.Write(resp)
                return //nolint:gosimple // (ignore redundant return)
        }</span>
}

func (d *Directory) handleStartTLS(t TestingT) func(w *gldap.ResponseWriter, r *gldap.Request) <span class="cov8" title="1">{
        const op = "testdirectory.(Directory).handleStartTLS"
        if v, ok := interface{}(t).(HelperT); ok </span><span class="cov8" title="1">{
                v.Helper()
        }</span>
        <span class="cov8" title="1">return func(w *gldap.ResponseWriter, r *gldap.Request) </span><span class="cov8" title="1">{
                d.logger.Debug(op)
                res := r.NewExtendedResponse(gldap.WithResponseCode(gldap.ResultSuccess))
                res.SetResponseName(gldap.ExtendedOperationStartTLS)
                err := w.Write(res)
                if err != nil </span><span class="cov0" title="0">{
                        d.logger.Error("error writing response: %s", "op", op, "err", err)
                        return
                }</span>
                <span class="cov8" title="1">if err := r.StartTLS(d.server); err != nil </span><span class="cov0" title="0">{
                        d.logger.Error("StartTLS Handshake error", "op", op, "err", err)
                        res.SetDiagnosticMessage(fmt.Sprintf("StartTLS Handshake error : \"%s\"", err.Error()))
                        res.SetResultCode(gldap.ResultOperationsError)
                        err := w.Write(res)
                        if err != nil </span><span class="cov0" title="0">{
                                d.logger.Error("error writing response: %s", "op", op, "err", err)
                                return
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
                <span class="cov8" title="1">d.logger.Debug("StartTLS OK", "op", op)</span>
        }
}

func (d *Directory) handleSearchGeneric(t TestingT) func(w *gldap.ResponseWriter, r *gldap.Request) <span class="cov8" title="1">{
        const op = "testdirectory.(Directory).handleSearchGeneric"
        if v, ok := interface{}(t).(HelperT); ok </span><span class="cov8" title="1">{
                v.Helper()
        }</span>
        <span class="cov8" title="1">return func(w *gldap.ResponseWriter, r *gldap.Request) </span><span class="cov8" title="1">{
                d.logger.Debug(op)
                res := r.NewSearchDoneResponse(gldap.WithResponseCode(gldap.ResultNoSuchObject))
                defer func() </span><span class="cov8" title="1">{
                        err := w.Write(res)
                        if err != nil </span><span class="cov0" title="0">{
                                d.logger.Error("error writing response: %s", "op", op, "err", err)
                                return
                        }</span>
                }()
                <span class="cov8" title="1">m, err := r.GetSearchMessage()
                if err != nil </span><span class="cov0" title="0">{
                        d.logger.Error("not a search message: %s", "op", op, "err", err)
                        return
                }</span>
                <span class="cov8" title="1">d.logSearchRequest(m)

                filter := m.Filter

                // if our search base is the base userDN, we're searching for a single
                // user, so adjust the filter to match user's entries
                if strings.Contains(string(m.BaseDN), d.userDN) </span><span class="cov8" title="1">{
                        filter = fmt.Sprintf("(%s)", m.BaseDN)
                        d.logger.Debug("new filter", "op", op, "value", filter)
                        for _, a := range m.Attributes </span><span class="cov8" title="1">{
                                d.logger.Debug("attr", "op", op, "value", a)
                                if a == "tokenGroups" </span><span class="cov0" title="0">{
                                        d.logger.Debug("asking for groups", "op", op)
                                }</span>
                        }
                }

                <span class="cov8" title="1">var foundEntries int

                // if our search base is a SID, then we're searching for tokenGroups
                if len(d.tokenGroups) &gt; 0 &amp;&amp; strings.HasPrefix(string(m.BaseDN), "&lt;SID=") </span><span class="cov8" title="1">{
                        sid := string(m.BaseDN)
                        sid = strings.TrimPrefix(sid, "&lt;SID=")
                        sid = strings.TrimSuffix(sid, "&gt;")
                        for _, g := range d.tokenGroups[sid] </span><span class="cov8" title="1">{
                                d.logger.Debug("found tokenGroup", "op", op, "group DN", g.DN)
                                result := r.NewSearchResponseEntry(g.DN)
                                for _, attr := range g.Attributes </span><span class="cov8" title="1">{
                                        result.AddAttribute(attr.Name, attr.Values)
                                }</span>
                                <span class="cov8" title="1">foundEntries += 1
                                err = w.Write(result)
                                if err != nil </span><span class="cov0" title="0">{
                                        d.logger.Error("error writing result: %s", "op", op, "err", err)
                                        return
                                }</span>
                        }
                        <span class="cov8" title="1">d.logger.Debug("found entries", "op", op, "count", foundEntries)
                        res.SetResultCode(gldap.ResultSuccess)
                        return</span>
                }

                <span class="cov8" title="1">d.logger.Debug("filter", "op", op, "value", filter)
                var entries []*gldap.Entry
                for _, e := range d.users </span><span class="cov8" title="1">{
                        if ok, _ := match(filter, e.DN); !ok </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">entries = append(entries, e)
                        foundEntries += 1</span>
                }
                <span class="cov8" title="1">for _, e := range d.groups </span><span class="cov8" title="1">{
                        if ok, _ := match(filter, e.DN); !ok </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov0" title="0">switch </span>{
                        case slices.Contains(entries, e):<span class="cov0" title="0">
                                continue</span>
                        default:<span class="cov0" title="0">
                                entries = append(entries, e)
                                foundEntries += 1</span>
                        }
                }
                <span class="cov8" title="1">if foundEntries &gt; 0 </span><span class="cov8" title="1">{
                        d.logger.Debug("found entries", "op", op, "count", foundEntries)
                        for _, e := range entries </span><span class="cov8" title="1">{
                                result := r.NewSearchResponseEntry(e.DN)
                                for _, attr := range e.Attributes </span><span class="cov8" title="1">{
                                        result.AddAttribute(attr.Name, attr.Values)
                                }</span>
                                <span class="cov8" title="1">foundEntries += 1
                                err := w.Write(result)
                                if err != nil </span><span class="cov0" title="0">{
                                        d.logger.Error("error writing result: %s", "op", op, "err", err)
                                        return
                                }</span>
                        }
                        <span class="cov8" title="1">if d.controls != nil </span><span class="cov0" title="0">{
                                d.mu.Lock()
                                defer d.mu.Unlock()
                                res.SetControls(d.controls...)
                        }</span>
                        <span class="cov8" title="1">res.SetResultCode(gldap.ResultSuccess)</span>
                }
        }
}

func (d *Directory) handleSearchGroups(t TestingT) func(w *gldap.ResponseWriter, r *gldap.Request) <span class="cov8" title="1">{
        const op = "testdirectory.(Directory).handleSearchGroups"
        if v, ok := interface{}(t).(HelperT); ok </span><span class="cov8" title="1">{
                v.Helper()
        }</span>
        <span class="cov8" title="1">return func(w *gldap.ResponseWriter, r *gldap.Request) </span><span class="cov8" title="1">{
                d.logger.Debug(op)
                res := r.NewSearchDoneResponse(gldap.WithResponseCode(gldap.ResultNoSuchObject))
                defer func() </span><span class="cov8" title="1">{
                        err := w.Write(res)
                        if err != nil </span><span class="cov0" title="0">{
                                d.logger.Error("error writing result: %s", "op", op, "err", err)
                                return
                        }</span>
                }()
                <span class="cov8" title="1">m, err := r.GetSearchMessage()
                if err != nil </span><span class="cov0" title="0">{
                        d.logger.Error("not a search message: %s", "op", op, "err", err)
                        return
                }</span>
                <span class="cov8" title="1">d.logSearchRequest(m)

                _, entries := d.findMembers(m.Filter)
                foundEntries := len(entries)

                for _, e := range d.groups </span><span class="cov8" title="1">{
                        if ok, _ := match(m.Filter, e.DN); !ok </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">switch </span>{
                        case slices.Contains(entries, e):<span class="cov0" title="0">
                                continue</span>
                        default:<span class="cov8" title="1">
                                entries = append(entries, e)</span>
                        }
                        <span class="cov8" title="1">foundEntries += 1</span>
                }

                <span class="cov8" title="1">if foundEntries &gt; 0 </span><span class="cov8" title="1">{
                        for _, e := range entries </span><span class="cov8" title="1">{
                                result := r.NewSearchResponseEntry(e.DN)
                                for _, attr := range e.Attributes </span><span class="cov8" title="1">{
                                        result.AddAttribute(attr.Name, attr.Values)
                                }</span>
                                <span class="cov8" title="1">foundEntries += 1
                                err = w.Write(result)
                                if err != nil </span><span class="cov0" title="0">{
                                        d.logger.Error("error writing result: %s", "op", op, "err", err)
                                        return
                                }</span>
                        }
                        <span class="cov8" title="1">d.logger.Debug("found entries", "op", op, "count", foundEntries)

                        if d.controls != nil </span><span class="cov8" title="1">{
                                d.mu.Lock()
                                defer d.mu.Unlock()
                                res.SetControls(d.controls...)
                        }</span>
                        <span class="cov8" title="1">res.SetResultCode(gldap.ResultSuccess)</span>
                }
        }
}

func (d *Directory) handleSearchUsers(t TestingT) func(w *gldap.ResponseWriter, r *gldap.Request) <span class="cov8" title="1">{
        const op = "testdirectory.(Directory).handleSearchUsers"
        if v, ok := interface{}(t).(HelperT); ok </span><span class="cov8" title="1">{
                v.Helper()
        }</span>
        <span class="cov8" title="1">return func(w *gldap.ResponseWriter, r *gldap.Request) </span><span class="cov8" title="1">{
                d.logger.Debug(op)
                res := r.NewSearchDoneResponse(gldap.WithResponseCode(gldap.ResultNoSuchObject))
                defer func() </span><span class="cov8" title="1">{
                        err := w.Write(res)
                        if err != nil </span><span class="cov0" title="0">{
                                d.logger.Error("error writing result: %s", "op", op, "err", err)
                                return
                        }</span>
                }()
                <span class="cov8" title="1">m, err := r.GetSearchMessage()
                if err != nil </span><span class="cov0" title="0">{
                        d.logger.Error("not a search message: %s", "op", op, "err", err)
                        return
                }</span>
                <span class="cov8" title="1">d.logSearchRequest(m)

                var foundEntries int
                _, _, entries := find(d.t, m.Filter, d.users)
                if len(entries) == 0 </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">for _, e := range entries </span><span class="cov8" title="1">{
                        result := r.NewSearchResponseEntry(e.DN)
                        for _, attr := range e.Attributes </span><span class="cov8" title="1">{
                                result.AddAttribute(attr.Name, attr.Values)
                        }</span>
                        <span class="cov8" title="1">foundEntries += 1
                        err := w.Write(result)
                        if err != nil </span><span class="cov0" title="0">{
                                d.logger.Error("error writing result: %s", "op", op, "err", err)
                                return
                        }</span>
                }
                <span class="cov8" title="1">if foundEntries &gt; 0 </span><span class="cov8" title="1">{
                        d.logger.Debug("found entries", "op", op, "count", foundEntries)
                        if d.controls != nil </span><span class="cov8" title="1">{
                                d.mu.Lock()
                                defer d.mu.Unlock()
                                res.SetControls(d.controls...)
                                fmt.Println(d.controls)
                        }</span>
                        <span class="cov8" title="1">res.SetResultCode(gldap.ResultSuccess)</span>
                }
        }
}

func (d *Directory) handleModify(t TestingT) func(w *gldap.ResponseWriter, r *gldap.Request) <span class="cov8" title="1">{
        const op = "testdirectory.(Directory).handleModify"
        if v, ok := interface{}(t).(HelperT); ok </span><span class="cov8" title="1">{
                v.Helper()
        }</span>
        <span class="cov8" title="1">return func(w *gldap.ResponseWriter, r *gldap.Request) </span><span class="cov8" title="1">{
                d.logger.Debug(op)
                res := r.NewModifyResponse(gldap.WithResponseCode(gldap.ResultNoSuchObject))
                defer func() </span><span class="cov8" title="1">{
                        err := w.Write(res)
                        if err != nil </span><span class="cov0" title="0">{
                                d.logger.Error("error writing result: %s", "op", op, "err", err)
                                return
                        }</span>
                }()
                <span class="cov8" title="1">m, err := r.GetModifyMessage()
                if err != nil </span><span class="cov0" title="0">{
                        d.logger.Error("not a modify message: %s", "op", op, "err", err)
                        return
                }</span>
                <span class="cov8" title="1">d.logger.Info("modify request", "dn", m.DN)

                var entries []*gldap.Entry
                _, _, entries = find(d.t, fmt.Sprintf("(%s)", m.DN), d.users)
                if len(entries) == 0 </span><span class="cov8" title="1">{
                        _, _, entries = find(d.t, m.DN, d.groups)
                }</span>
                <span class="cov8" title="1">if len(entries) == 0 </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">if len(entries) &gt; 1 </span><span class="cov0" title="0">{
                        res.SetResultCode(gldap.ResultInappropriateMatching)
                        res.SetDiagnosticMessage(fmt.Sprintf("more than one match: %d entries", len(entries)))
                        return
                }</span>
                <span class="cov8" title="1">d.mu.Lock()
                defer d.mu.Unlock()
                e := entries[0]
                if entries[0].Attributes == nil </span><span class="cov0" title="0">{
                        e.Attributes = []*gldap.EntryAttribute{}
                }</span>
                <span class="cov8" title="1">res.SetMatchedDN(entries[0].DN)
                for _, chg := range m.Changes </span><span class="cov8" title="1">{
                        // find specific attr
                        var foundAttr *gldap.EntryAttribute
                        var foundAt int
                        for i, a := range e.Attributes </span><span class="cov8" title="1">{
                                if a.Name == chg.Modification.Type </span><span class="cov8" title="1">{
                                        foundAttr = a
                                        foundAt = i
                                }</span>
                        }
                        // then apply operation
                        <span class="cov8" title="1">switch chg.Operation </span>{
                        case gldap.AddAttribute:<span class="cov8" title="1">
                                if foundAttr != nil </span><span class="cov0" title="0">{
                                        foundAttr.AddValue(chg.Modification.Vals...)
                                }</span> else<span class="cov8" title="1"> {
                                        e.Attributes = append(e.Attributes, gldap.NewEntryAttribute(chg.Modification.Type, chg.Modification.Vals))
                                }</span>
                        case gldap.DeleteAttribute:<span class="cov8" title="1">
                                if foundAttr != nil </span><span class="cov8" title="1">{
                                        // slice out the deleted attribute
                                        copy(e.Attributes[foundAt:], e.Attributes[foundAt+1:])
                                        e.Attributes = e.Attributes[:len(e.Attributes)-1]
                                }</span>
                        case gldap.ReplaceAttribute:<span class="cov8" title="1">
                                if foundAttr != nil </span><span class="cov8" title="1">{
                                        // we're updating what the ptr points at, so disable lint of
                                        // unused var
                                        //nolint:staticcheck
                                        foundAttr = gldap.NewEntryAttribute(chg.Modification.Type, chg.Modification.Vals)
                                }</span>
                        }
                }
                <span class="cov8" title="1">res.SetResultCode(gldap.ResultSuccess)</span>
        }
}

func (d *Directory) handleAdd(t TestingT) func(w *gldap.ResponseWriter, r *gldap.Request) <span class="cov8" title="1">{
        const op = "testdirectory.(Directory).handleAdd"
        if v, ok := interface{}(t).(HelperT); ok </span><span class="cov8" title="1">{
                v.Helper()
        }</span>
        <span class="cov8" title="1">return func(w *gldap.ResponseWriter, r *gldap.Request) </span><span class="cov8" title="1">{
                d.logger.Debug(op)
                res := r.NewResponse(gldap.WithApplicationCode(gldap.ApplicationAddResponse), gldap.WithResponseCode(gldap.ResultOperationsError))
                defer func() </span><span class="cov8" title="1">{
                        err := w.Write(res)
                        if err != nil </span><span class="cov0" title="0">{
                                d.logger.Error("error writing result: %s", "op", op, "err", err)
                                return
                        }</span>
                }()
                <span class="cov8" title="1">m, err := r.GetAddMessage()
                if err != nil </span><span class="cov0" title="0">{
                        d.logger.Error("not an add message: %s", "op", op, "err", err)
                        return
                }</span>
                <span class="cov8" title="1">d.logger.Info("add request", "dn", m.DN)

                if found, _, _ := find(d.t, fmt.Sprintf("(%s)", m.DN), d.users); found </span><span class="cov8" title="1">{
                        res.SetResultCode(gldap.ResultEntryAlreadyExists)
                        res.SetDiagnosticMessage(fmt.Sprintf("entry exists for DN: %s", m.DN))
                        return
                }</span>
                <span class="cov8" title="1">attrs := map[string][]string{}
                for _, a := range m.Attributes </span><span class="cov8" title="1">{
                        attrs[a.Type] = a.Vals
                }</span>
                <span class="cov8" title="1">newEntry := gldap.NewEntry(m.DN, attrs)
                d.mu.Lock()
                defer d.mu.Unlock()
                d.users = append(d.users, newEntry)
                res.SetResultCode(gldap.ResultSuccess)</span>
        }
}

func (d *Directory) handleDelete(t TestingT) func(w *gldap.ResponseWriter, r *gldap.Request) <span class="cov8" title="1">{
        const op = "testdirectory.(Directory).handleDelete"
        if v, ok := interface{}(t).(HelperT); ok </span><span class="cov8" title="1">{
                v.Helper()
        }</span>
        <span class="cov8" title="1">return func(w *gldap.ResponseWriter, r *gldap.Request) </span><span class="cov8" title="1">{
                d.logger.Debug(op)
                res := r.NewResponse(gldap.WithResponseCode(gldap.ResultNoSuchObject), gldap.WithApplicationCode(gldap.ApplicationDelResponse))
                defer func() </span><span class="cov8" title="1">{
                        err := w.Write(res)
                        if err != nil </span><span class="cov0" title="0">{
                                d.logger.Error("error writing response: %s", "op", op, "err", err)
                                return
                        }</span>
                }()
                <span class="cov8" title="1">m, err := r.GetDeleteMessage()
                if err != nil </span><span class="cov0" title="0">{
                        d.logger.Error("not a delete message: %s", "op", op, "err", err)
                        return
                }</span>
                <span class="cov8" title="1">d.logger.Info("delete request", "dn", m.DN)

                _, foundAt, _ := find(d.t, fmt.Sprintf("(%s)", m.DN), d.users)
                if len(foundAt) &gt; 0 </span><span class="cov8" title="1">{
                        if len(foundAt) &gt; 1 </span><span class="cov0" title="0">{
                                res.SetResultCode(gldap.ResultInappropriateMatching)
                                res.SetDiagnosticMessage(fmt.Sprintf("more than one match: %d entries", len(foundAt)))
                                return
                        }</span>
                        <span class="cov8" title="1">d.mu.Lock()
                        defer d.mu.Unlock()
                        d.users = append(d.users[:foundAt[0]], d.users[foundAt[0]+1:]...)
                        res.SetResultCode(gldap.ResultSuccess)
                        return</span>
                }
                <span class="cov8" title="1">_, foundAt, _ = find(d.t, fmt.Sprintf("(%s)", m.DN), d.groups)
                if len(foundAt) &gt; 0 </span><span class="cov8" title="1">{
                        if len(foundAt) &gt; 1 </span><span class="cov0" title="0">{
                                res.SetResultCode(gldap.ResultInappropriateMatching)
                                res.SetDiagnosticMessage(fmt.Sprintf("more than one match: %d entries", len(foundAt)))
                                return
                        }</span>
                        <span class="cov8" title="1">d.mu.Lock()
                        defer d.mu.Unlock()
                        d.groups = append(d.groups[:foundAt[0]], d.groups[foundAt[0]+1:]...)
                        res.SetResultCode(gldap.ResultSuccess)
                        return</span>
                }
                <span class="cov8" title="1">return</span> //nolint:gosimple // (ignore redundant return)
        }
}

func (d *Directory) findMembers(filter string, opt ...Option) (bool, []*gldap.Entry) <span class="cov8" title="1">{
        opts := getOpts(d.t, opt...)
        var matches []*gldap.Entry
        for _, e := range d.groups </span><span class="cov8" title="1">{
                members := e.GetAttributeValues("member")
                for _, m := range members </span><span class="cov8" title="1">{
                        if ok, _ := match(filter, "member="+m); ok </span><span class="cov8" title="1">{
                                matches = append(matches, e)
                                if opts.withFirst </span><span class="cov0" title="0">{
                                        return true, matches
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">if len(matches) &gt; 0 </span><span class="cov8" title="1">{
                return true, matches
        }</span>
        <span class="cov8" title="1">return false, nil</span>
}

func find(t TestingT, filter string, entries []*gldap.Entry, opt ...Option) (bool, []int, []*gldap.Entry) <span class="cov8" title="1">{
        opts := getOpts(t, opt...)
        var matches []*gldap.Entry
        var matchIndexes []int
        for idx, e := range entries </span><span class="cov8" title="1">{
                if ok, _ := match(filter, e.DN); ok </span><span class="cov8" title="1">{
                        matches = append(matches, e)
                        matchIndexes = append(matchIndexes, idx)
                        if opts.withFirst </span><span class="cov0" title="0">{
                                return true, []int{idx}, matches
                        }</span>
                }
        }
        <span class="cov8" title="1">if len(matches) &gt; 0 </span><span class="cov8" title="1">{
                return true, matchIndexes, matches
        }</span>
        <span class="cov8" title="1">return false, nil, nil</span>
}

func match(filter string, attr string) (bool, error) <span class="cov8" title="1">{
        // TODO: make this actually do something more reasonable with the search
        // request filter
        re := regexp.MustCompile(`\((.*?)\)`)
        submatchall := re.FindAllString(filter, -1)
        for _, element := range submatchall </span><span class="cov8" title="1">{
                element = strings.ReplaceAll(element, "*", "")
                element = strings.Trim(element, "|(")
                element = strings.Trim(element, "(")
                element = strings.Trim(element, ")")
                element = strings.TrimSpace(element)
                if strings.Contains(attr, element) </span><span class="cov8" title="1">{
                        return true, nil
                }</span>
        }
        <span class="cov8" title="1">return false, nil</span>
}

// Conn returns an *ldap.Conn that's connected (using whatever tls.Config is
// appropriate for the directory) and ready send requests to the directory.
func (d *Directory) Conn() *ldap.Conn <span class="cov8" title="1">{
        if v, ok := interface{}(d.t).(HelperT); ok </span><span class="cov8" title="1">{
                v.Helper()
        }</span>
        <span class="cov8" title="1">require := require.New(d.t)

        var conn *ldap.Conn
        retryAttempt := 5
        retryErrFn := func(e error) error </span><span class="cov0" title="0">{
                if retryAttempt &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Println(retryAttempt)
                        retryAttempt--
                        return backoff.Permanent(e)
                }</span>
                <span class="cov0" title="0">return backoff.Permanent(e)</span>
        }
        <span class="cov8" title="1">err := backoff.Retry(func() error </span><span class="cov8" title="1">{
                var connErr error
                if d.useTLS </span><span class="cov8" title="1">{
                        if conn, connErr = ldap.DialURL(fmt.Sprintf("ldaps://%s:%d", d.Host(), d.Port()), ldap.DialWithTLSConfig(d.client)); connErr != nil </span><span class="cov0" title="0">{
                                return retryErrFn(connErr)
                        }</span>
                        <span class="cov8" title="1">return nil</span>
                }
                <span class="cov8" title="1">if conn, connErr = ldap.DialURL(fmt.Sprintf("ldap://%s:%d", d.Host(), d.Port())); connErr != nil </span><span class="cov0" title="0">{
                        return retryErrFn(connErr)
                }</span>
                <span class="cov8" title="1">return nil</span>
        }, backoff.NewConstantBackOff(1*time.Second))
        <span class="cov8" title="1">require.NoError(err)
        return conn</span>
}

// Cert returns the pem-encoded certificate used by the Directory.
func (d *Directory) Cert() string <span class="cov8" title="1">{
        if v, ok := interface{}(d.t).(HelperT); ok </span><span class="cov8" title="1">{
                v.Helper()
        }</span>
        <span class="cov8" title="1">require := require.New(d.t)

        require.NotNil(d.server)
        require.Len(d.server.Certificates, 1)
        cert := d.server.Certificates[0]
        require.NotNil(cert)
        require.Len(cert.Certificate, 1)
        var buf bytes.Buffer
        err := pem.Encode(&amp;buf, &amp;pem.Block{Type: "CERTIFICATE", Bytes: cert.Certificate[0]})
        require.NoError(err)
        return buf.String()</span>
}

// Port returns the port the directory is listening on
func (d *Directory) Port() int <span class="cov8" title="1">{
        if v, ok := interface{}(d.t).(HelperT); ok </span><span class="cov8" title="1">{
                v.Helper()
        }</span>
        <span class="cov8" title="1">return d.port</span>
}

// Host returns the host the directory is listening on
func (d *Directory) Host() string <span class="cov8" title="1">{
        if v, ok := interface{}(d.t).(HelperT); ok </span><span class="cov8" title="1">{
                v.Helper()
        }</span>
        <span class="cov8" title="1">return d.host</span>
}

// ClientCert returns the pem-encoded certificate which can be used by a client
// for mTLS.
func (d *Directory) ClientCert() string <span class="cov8" title="1">{
        if v, ok := interface{}(d.t).(HelperT); ok </span><span class="cov8" title="1">{
                v.Helper()
        }</span>
        <span class="cov8" title="1">require := require.New(d.t)

        require.NotNil(d.client)
        require.Len(d.client.Certificates, 1)
        cert := d.client.Certificates[0]
        require.NotNil(cert)
        require.Len(cert.Certificate, 1)
        var buf bytes.Buffer
        err := pem.Encode(&amp;buf, &amp;pem.Block{Type: "CERTIFICATE", Bytes: cert.Certificate[0]})
        require.NoError(err)
        return buf.String()</span>
}

// ClientKey returns the pem-encoded private key which can be used by a client
// for mTLS.
func (d *Directory) ClientKey() string <span class="cov8" title="1">{
        if v, ok := interface{}(d.t).(HelperT); ok </span><span class="cov8" title="1">{
                v.Helper()
        }</span>
        <span class="cov8" title="1">require := require.New(d.t)

        require.NotNil(d.client)
        require.Len(d.client.Certificates, 1)
        privBytes, err := x509.MarshalPKCS8PrivateKey(d.client.Certificates[0].PrivateKey)
        require.NoError(err)
        pemKey := pem.EncodeToMemory(&amp;pem.Block{Type: "PRIVATE KEY", Bytes: privBytes})
        require.NotNil(pemKey)
        return string(pemKey)</span>
}

// Controls returns all the current bind controls for the Directory
func (d *Directory) Controls() []gldap.Control <span class="cov8" title="1">{
        return d.controls
}</span>

// SetControls sets the bind controls.
func (d *Directory) SetControls(controls ...gldap.Control) <span class="cov8" title="1">{
        if v, ok := interface{}(d.t).(HelperT); ok </span><span class="cov8" title="1">{
                v.Helper()
        }</span>
        <span class="cov8" title="1">d.mu.Lock()
        defer d.mu.Unlock()
        d.controls = controls</span>
}

// Users returns all the current user entries in the Directory
func (d *Directory) Users() []*gldap.Entry <span class="cov8" title="1">{
        return d.users
}</span>

// SetUsers sets the user entries.
func (d *Directory) SetUsers(users ...*gldap.Entry) <span class="cov8" title="1">{
        if v, ok := interface{}(d.t).(HelperT); ok </span><span class="cov8" title="1">{
                v.Helper()
        }</span>
        <span class="cov8" title="1">d.mu.Lock()
        defer d.mu.Unlock()
        d.users = users</span>
}

// Groups returns all the current group entries in the Directory
func (d *Directory) Groups() []*gldap.Entry <span class="cov8" title="1">{
        return d.groups
}</span>

// SetGroups sets the group entries.
func (d *Directory) SetGroups(groups ...*gldap.Entry) <span class="cov8" title="1">{
        if v, ok := interface{}(d.t).(HelperT); ok </span><span class="cov8" title="1">{
                v.Helper()
        }</span>
        <span class="cov8" title="1">d.mu.Lock()
        defer d.mu.Unlock()
        d.groups = groups</span>
}

// SetTokenGroups will set the tokenGroup entries.
func (d *Directory) SetTokenGroups(tokenGroups map[string][]*gldap.Entry) <span class="cov8" title="1">{
        if v, ok := interface{}(d.t).(HelperT); ok </span><span class="cov8" title="1">{
                v.Helper()
        }</span>
        <span class="cov8" title="1">d.mu.Lock()
        defer d.mu.Unlock()
        d.tokenGroups = tokenGroups</span>
}

// TokenGroups will return the tokenGroup entries
func (d *Directory) TokenGroups() map[string][]*gldap.Entry <span class="cov8" title="1">{
        return d.tokenGroups
}</span>

// AllowAnonymousBind returns the allow anon bind setting
func (d *Directory) AllowAnonymousBind() bool <span class="cov8" title="1">{
        return d.allowAnonymousBind
}</span>

// SetAllowAnonymousBind enables/disables anon binds
func (d *Directory) SetAllowAnonymousBind(enabled bool) <span class="cov8" title="1">{
        if v, ok := interface{}(d.t).(HelperT); ok </span><span class="cov8" title="1">{
                v.Helper()
        }</span>
        <span class="cov8" title="1">d.mu.Lock()
        defer d.mu.Unlock()
        d.allowAnonymousBind = enabled</span>
}

func (d *Directory) logSearchRequest(m *gldap.SearchMessage) <span class="cov8" title="1">{
        d.logger.Info("search request",
                "baseDN", m.BaseDN,
                "scope", m.Scope,
                "filter", m.Filter,
                "attributes", m.Attributes,
        )
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package testdirectory

import (
        "strings"

        "github.com/hashicorp/go-hclog"
        "github.com/jimlambrt/gldap"
)

// Option defines a common functional options type which can be used in a
// variadic parameter pattern.
type Option func(interface{})

// getOpts gets the defaults and applies the opt overrides passed in
func getOpts(t TestingT, opt ...Option) options <span class="cov8" title="1">{
        if v, ok := interface{}(t).(HelperT); ok </span><span class="cov8" title="1">{
                v.Helper()
        }</span>
        <span class="cov8" title="1">opts := defaults(t)
        applyOpts(&amp;opts, opt...)
        return opts</span>
}

// applyOpts takes a pointer to the options struct as a set of default options
// and applies the slice of opts as overrides.
func applyOpts(opts interface{}, opt ...Option) <span class="cov8" title="1">{
        for _, o := range opt </span><span class="cov8" title="1">{
                if o == nil </span><span class="cov8" title="1">{ // ignore any nil Options
                        continue</span>
                }
                <span class="cov8" title="1">o(opts)</span>
        }
}

// options are the set of available options for test functions
type options struct {
        withPort                 int
        withHost                 string
        withLogger               hclog.Logger
        withNoTLS                bool
        withMTLS                 bool
        withDisablePanicRecovery bool
        withDefaults             *Defaults

        withMembersOf      []string
        withTokenGroupSIDs [][]byte

        withFirst bool
}

func defaults(t TestingT) options <span class="cov8" title="1">{
        if v, ok := interface{}(t).(HelperT); ok </span><span class="cov8" title="1">{
                v.Helper()
        }</span>
        <span class="cov8" title="1">debugLogger := hclog.New(&amp;hclog.LoggerOptions{
                Name:  "testdirectory-default-logger",
                Level: hclog.Error,
        })

        return options{
                withLogger: debugLogger,
                withHost:   "localhost",
                withDefaults: &amp;Defaults{
                        UserAttr:  DefaultUserAttr,
                        GroupAttr: DefaultGroupAttr,
                        UserDN:    DefaultUserDN,
                        GroupDN:   DefaultGroupDN,
                },
        }</span>
}

// Defaults define a type for composing all the defaults for Directory.Start(...)
type Defaults struct {
        UserAttr string

        GroupAttr string

        // Users configures the user entries which are empty by default
        Users []*gldap.Entry

        // Groups configures the group entries which are empty by default
        Groups []*gldap.Entry

        // TokenGroups configures the tokenGroup entries which are empty be default
        TokenGroups map[string][]*gldap.Entry

        // UserDN is the base distinguished name to use when searching for users
        // which is "ou=people,dc=example,dc=org" by default
        UserDN string

        // GroupDN is the base distinguished name to use when searching for groups
        // which is "ou=groups,dc=example,dc=org" by default
        GroupDN string

        // AllowAnonymousBind determines if anon binds are allowed
        AllowAnonymousBind bool

        // UPNDomain is the userPrincipalName domain, which enables a
        // userPrincipalDomain login with [username]@UPNDomain (optional)
        UPNDomain string
}

// WithDefaults provides an option to provide a set of defaults to
// Directory.Start(...) which make it much more composable.
func WithDefaults(t TestingT, defaults *Defaults) Option <span class="cov8" title="1">{
        return func(o interface{}) </span><span class="cov8" title="1">{
                if o, ok := o.(*options); ok </span><span class="cov8" title="1">{
                        if defaults != nil </span><span class="cov8" title="1">{
                                if defaults.AllowAnonymousBind </span><span class="cov8" title="1">{
                                        o.withDefaults.AllowAnonymousBind = true
                                }</span>
                                <span class="cov8" title="1">if defaults.Users != nil </span><span class="cov8" title="1">{
                                        o.withDefaults.Users = defaults.Users
                                }</span>
                                <span class="cov8" title="1">if defaults.Groups != nil </span><span class="cov8" title="1">{
                                        o.withDefaults.Groups = defaults.Groups
                                }</span>
                                <span class="cov8" title="1">if defaults.UserDN != "" </span><span class="cov8" title="1">{
                                        o.withDefaults.UserDN = defaults.UserDN
                                }</span>
                                <span class="cov8" title="1">if defaults.GroupDN != "" </span><span class="cov8" title="1">{
                                        o.withDefaults.GroupDN = defaults.GroupDN
                                }</span>
                                <span class="cov8" title="1">if len(defaults.TokenGroups) &gt; 0 </span><span class="cov8" title="1">{
                                        o.withDefaults.TokenGroups = defaults.TokenGroups
                                }</span>
                                <span class="cov8" title="1">if defaults.UserAttr != "" </span><span class="cov8" title="1">{
                                        o.withDefaults.UserAttr = defaults.UserAttr
                                }</span>
                                <span class="cov8" title="1">if defaults.GroupAttr != "" </span><span class="cov8" title="1">{
                                        o.withDefaults.GroupAttr = defaults.GroupAttr
                                }</span>
                                <span class="cov8" title="1">if defaults.UPNDomain != "" </span><span class="cov8" title="1">{
                                        o.withDefaults.UPNDomain = defaults.UPNDomain
                                }</span>
                        }
                }
        }
}

// WithMTLS provides the option to use mTLS for the directory.
func WithMTLS(t TestingT) Option <span class="cov8" title="1">{
        return func(o interface{}) </span><span class="cov8" title="1">{
                if o, ok := o.(*options); ok </span><span class="cov8" title="1">{
                        o.withMTLS = true
                }</span>
        }
}

// WithNoTLS provides the option to not use TLS for the directory.
func WithNoTLS(t TestingT) Option <span class="cov8" title="1">{
        return func(o interface{}) </span><span class="cov8" title="1">{
                if o, ok := o.(*options); ok </span><span class="cov8" title="1">{
                        o.withNoTLS = true
                }</span>
        }
}

// WithLogger provides the optional logger for the directory.
func WithLogger(t TestingT, l hclog.Logger) Option <span class="cov8" title="1">{
        return func(o interface{}) </span><span class="cov8" title="1">{
                if o, ok := o.(*options); ok </span><span class="cov8" title="1">{
                        o.withLogger = l
                }</span>
        }
}

// WithPort provides an optional port for the directory. 0 causes a
// started server with a random port. Any other value returns a started server
// on that port.
func WithPort(t TestingT, port int) Option <span class="cov8" title="1">{
        return func(o interface{}) </span><span class="cov8" title="1">{
                if o, ok := o.(*options); ok </span><span class="cov8" title="1">{
                        o.withPort = port
                }</span>
        }
}

// WithHost provides an optional hostname for the directory
func WithHost(t TestingT, host string) Option <span class="cov8" title="1">{
        return func(o interface{}) </span><span class="cov8" title="1">{
                if o, ok := o.(*options); ok </span><span class="cov8" title="1">{
                        o.withHost = strings.TrimSpace(host)
                }</span>
        }
}

// withFirst provides the option to only find the first match.
func withFirst(t TestingT) Option <span class="cov8" title="1">{
        return func(o interface{}) </span><span class="cov8" title="1">{
                if o, ok := o.(*options); ok </span><span class="cov8" title="1">{
                        o.withFirst = true
                }</span>
        }
}

// WithMembersOf specifies optional memberOf attributes for user
// entries
func WithMembersOf(t TestingT, membersOf ...string) Option <span class="cov8" title="1">{
        return func(o interface{}) </span><span class="cov8" title="1">{
                if o, ok := o.(*options); ok </span><span class="cov8" title="1">{
                        o.withMembersOf = membersOf
                }</span>
        }
}

// WithTokenGroups specifies optional test tokenGroups SID attributes for user
// entries
func WithTokenGroups(t TestingT, tokenGroupSID ...[]byte) Option <span class="cov8" title="1">{
        return func(o interface{}) </span><span class="cov8" title="1">{
                if o, ok := o.(*options); ok </span><span class="cov8" title="1">{
                        o.withTokenGroupSIDs = tokenGroupSID
                }</span>
        }
}

func WithDisablePanicRecovery(t TestingT, disable bool) Option <span class="cov8" title="1">{
        return func(o interface{}) </span><span class="cov8" title="1">{
                if o, ok := o.(*options); ok </span><span class="cov8" title="1">{
                        o.withDisablePanicRecovery = disable
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package testdirectory

import (
        "bytes"
        "crypto/ecdsa"
        "crypto/elliptic"
        "crypto/rand"
        "crypto/tls"
        "crypto/x509"
        "crypto/x509/pkix"
        "encoding/pem"
        "fmt"
        "math/big"
        "net"
        "time"

        "github.com/jimlambrt/gldap"
        "github.com/stretchr/testify/require"
)

// NewMemberOf creates memberOf attributes which can be assigned to user
// entries.  Supported Options: WithDefaults
func NewMemberOf(t TestingT, groupNames []string, opt ...Option) []string <span class="cov8" title="1">{
        opts := getOpts(t, opt...)
        DNs := make([]string, 0, len(groupNames))
        for _, n := range groupNames </span><span class="cov8" title="1">{
                DNs = append(DNs, fmt.Sprintf("%s=%s,%s", opts.withDefaults.GroupAttr, n, opts.withDefaults.GroupDN))
        }</span>
        <span class="cov8" title="1">return DNs</span>
}

// NewUsers creates user entries.  Options supported: WithDefaults, WithMembersOf
func NewUsers(t TestingT, userNames []string, opt ...Option) []*gldap.Entry <span class="cov8" title="1">{
        opts := getOpts(t, opt...)

        entries := make([]*gldap.Entry, 0, len(userNames))
        for _, n := range userNames </span><span class="cov8" title="1">{
                entryAttrs := map[string][]string{
                        "name":     {n},
                        "email":    {fmt.Sprintf("%s@example.com", n)},
                        "password": {"password"},
                }
                if len(opts.withMembersOf) &gt; 0 </span><span class="cov8" title="1">{
                        entryAttrs["memberOf"] = opts.withMembersOf
                }</span>
                <span class="cov8" title="1">if len(opts.withTokenGroupSIDs) &gt; 0 </span><span class="cov8" title="1">{
                        groups := make([]string, 0, len(opts.withTokenGroupSIDs))
                        for _, s := range opts.withTokenGroupSIDs </span><span class="cov8" title="1">{
                                groups = append(groups, string(s))
                        }</span>
                        <span class="cov8" title="1">entryAttrs["tokenGroups"] = groups</span>
                }
                <span class="cov8" title="1">var DN string
                switch </span>{
                case opts.withDefaults.UPNDomain != "":<span class="cov8" title="1">
                        DN = fmt.Sprintf("userPrincipalName=%s@%s,%s", n, opts.withDefaults.UPNDomain, opts.withDefaults.UserDN)</span>
                default:<span class="cov8" title="1">
                        DN = fmt.Sprintf("%s=%s,%s", opts.withDefaults.UserAttr, n, opts.withDefaults.UserDN)</span>
                }
                <span class="cov8" title="1">entries = append(entries,
                        gldap.NewEntry(
                                DN,
                                entryAttrs,
                        ),
                )</span>
        }
        <span class="cov8" title="1">return entries</span>
}

// NewGroup creates a group entry.  Options supported: WithDefaults
func NewGroup(t TestingT, groupName string, memberNames []string, opt ...Option) *gldap.Entry <span class="cov8" title="1">{
        opts := getOpts(t, opt...)

        members := make([]string, 0, len(memberNames))
        for _, n := range memberNames </span><span class="cov8" title="1">{
                var DN string
                switch </span>{
                case opts.withDefaults.UPNDomain != "":<span class="cov8" title="1">
                        DN = fmt.Sprintf("userPrincipalName=%s@%s,%s", n, opts.withDefaults.UPNDomain, opts.withDefaults.UserDN)</span>
                default:<span class="cov8" title="1">
                        DN = fmt.Sprintf("%s=%s,%s", opts.withDefaults.UserAttr, n, opts.withDefaults.UserDN)</span>
                }
                <span class="cov8" title="1">members = append(members, DN)</span>
        }
        <span class="cov8" title="1">return gldap.NewEntry(
                fmt.Sprintf("%s=%s,%s", opts.withDefaults.GroupAttr, groupName, opts.withDefaults.GroupDN),
                map[string][]string{
                        "member": members,
                })</span>
}

// FreePort just returns an available free localhost port
func FreePort(t TestingT) int <span class="cov8" title="1">{
        if v, ok := interface{}(t).(HelperT); ok </span><span class="cov8" title="1">{
                v.Helper()
        }</span>
        <span class="cov8" title="1">require := require.New(t)
        addr, err := net.ResolveTCPAddr("tcp", "localhost:0")
        require.NoError(err)

        l, err := net.ListenTCP("tcp", addr)
        require.NoError(err)
        defer l.Close()
        return l.Addr().(*net.TCPAddr).Port</span>
}

// supports WithMTLS
func GetTLSConfig(t TestingT, opt ...Option) (s *tls.Config, c *tls.Config) <span class="cov8" title="1">{
        if v, ok := interface{}(t).(HelperT); ok </span><span class="cov8" title="1">{
                v.Helper()
        }</span>
        <span class="cov8" title="1">require := require.New(t)

        certSubject := pkix.Name{
                Organization:  []string{"Acme, INC."},
                Country:       []string{"US"},
                Province:      []string{""},
                Locality:      []string{"New York"},
                StreetAddress: []string{"Empire State Building"},
                PostalCode:    []string{"10118"},
        }
        // set up our CA certificate
        ca := &amp;x509.Certificate{
                SerialNumber:          genSerialNumber(t),
                Subject:               certSubject,
                NotBefore:             time.Now(),
                NotAfter:              time.Now().AddDate(1, 0, 0),
                IsCA:                  true,
                ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageClientAuth, x509.ExtKeyUsageServerAuth},
                KeyUsage:              x509.KeyUsageDigitalSignature | x509.KeyUsageCertSign,
                BasicConstraintsValid: true,
        }
        caPriv, err := ecdsa.GenerateKey(elliptic.P521(), rand.Reader)
        require.NoError(err)

        caBytes, err := x509.CreateCertificate(rand.Reader, ca, ca, &amp;caPriv.PublicKey, caPriv)
        require.NoError(err)

        caPEM := new(bytes.Buffer)
        err = pem.Encode(caPEM, &amp;pem.Block{
                Type:  "CERTIFICATE",
                Bytes: caBytes,
        })
        require.NoError(err)

        privBytes, err := x509.MarshalPKCS8PrivateKey(caPriv)
        require.NoError(err)
        caPrivKeyPEM := new(bytes.Buffer)
        err = pem.Encode(caPrivKeyPEM, &amp;pem.Block{
                Type:  "PRIVATE KEY",
                Bytes: privBytes,
        })
        require.NoError(err)
        opts := getOpts(t, opt...)

        var ipAddrs []net.IP
        if hostIp := net.ParseIP(opts.withHost); hostIp != nil </span><span class="cov8" title="1">{
                ipAddrs = append(ipAddrs, hostIp)
        }</span>

        <span class="cov8" title="1">cert := &amp;x509.Certificate{
                SerialNumber:          genSerialNumber(t),
                Subject:               certSubject,
                IPAddresses:           ipAddrs,
                DNSNames:              []string{opts.withHost},
                NotBefore:             time.Now(),
                NotAfter:              time.Now().AddDate(1, 0, 0),
                SubjectKeyId:          []byte{1, 2, 3, 4, 6},
                ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageClientAuth, x509.ExtKeyUsageServerAuth},
                KeyUsage:              x509.KeyUsageDigitalSignature,
                BasicConstraintsValid: true,
        }

        serverCert := genCert(t, ca, caPriv, cert)

        certpool := x509.NewCertPool()
        certpool.AppendCertsFromPEM(caPEM.Bytes())

        serverTLSConf := &amp;tls.Config{
                Certificates: []tls.Certificate{serverCert},
        }

        clientTLSConf := &amp;tls.Config{
                RootCAs: certpool,
        }

        if opts.withMTLS </span><span class="cov8" title="1">{
                // setup mTLS for certs from the ca
                serverTLSConf.ClientCAs = certpool
                serverTLSConf.ClientAuth = tls.RequireAndVerifyClientCert

                cert := &amp;x509.Certificate{
                        SerialNumber:          big.NewInt(2019),
                        Subject:               certSubject,
                        EmailAddresses:        []string{"mtls.client@example.com"},
                        NotBefore:             time.Now(),
                        NotAfter:              time.Now().AddDate(1, 0, 0),
                        SubjectKeyId:          []byte{1, 2, 3, 4, 6},
                        ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageClientAuth, x509.ExtKeyUsageServerAuth},
                        KeyUsage:              x509.KeyUsageDigitalSignature,
                        BasicConstraintsValid: true,
                }
                clientCert := genCert(t, ca, caPriv, cert)
                clientTLSConf.Certificates = []tls.Certificate{clientCert}
        }</span>

        <span class="cov8" title="1">return serverTLSConf, clientTLSConf</span>
}

func genCert(t TestingT, ca *x509.Certificate, caPriv interface{}, certTemplate *x509.Certificate) tls.Certificate <span class="cov8" title="1">{
        if v, ok := interface{}(t).(HelperT); ok </span><span class="cov8" title="1">{
                v.Helper()
        }</span>
        <span class="cov8" title="1">require := require.New(t)
        certPrivKey, err := ecdsa.GenerateKey(elliptic.P521(), rand.Reader)
        require.NoError(err)

        certBytes, err := x509.CreateCertificate(rand.Reader, certTemplate, ca, &amp;certPrivKey.PublicKey, caPriv)
        require.NoError(err)

        certPEM := new(bytes.Buffer)
        err = pem.Encode(certPEM, &amp;pem.Block{
                Type:  "CERTIFICATE",
                Bytes: certBytes,
        })
        require.NoError(err)

        privBytes, err := x509.MarshalPKCS8PrivateKey(certPrivKey)
        require.NoError(err)

        certPrivKeyPEM := new(bytes.Buffer)
        err = pem.Encode(certPrivKeyPEM, &amp;pem.Block{
                Type:  "PRIVATE KEY",
                Bytes: privBytes,
        })
        require.NoError(err)

        newCert, err := tls.X509KeyPair(certPEM.Bytes(), certPrivKeyPEM.Bytes())
        require.NoError(err)
        return newCert</span>
}

func genSerialNumber(t TestingT) *big.Int <span class="cov8" title="1">{
        if v, ok := interface{}(t).(HelperT); ok </span><span class="cov8" title="1">{
                v.Helper()
        }</span>
        <span class="cov8" title="1">require := require.New(t)
        serialNumberLimit := new(big.Int).Lsh(big.NewInt(1), 128)
        serialNumber, err := rand.Int(rand.Reader, serialNumberLimit)
        require.NoError(err)
        return serialNumber</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package testdirectory

import (
        "errors"

        "github.com/hashicorp/go-hclog"
)

// TestingT defines a very slim interface required by a Directory and any
// test functions it uses.
type TestingT interface {
        Errorf(format string, args ...interface{})
        FailNow()
        Log(...interface{})
}

// CleanupT defines an single function interface for a testing.Cleanup(func()).
type CleanupT interface{ Cleanup(func()) }

// HelperT defines a single function interface for a testing.Helper()
type HelperT interface{ Helper() }

// InfofT defines a single function interface for a Info(format string, args ...interface{})
type InfofT interface {
        Infof(format string, args ...interface{})
}

// Logger defines a logger that will implement the TestingT interface so
// it can be used with Directory.Start(...) as its t TestingT parameter.
type Logger struct {
        Logger hclog.Logger
}

// NewLogger makes a new TestingLogger
func NewLogger(logger hclog.Logger) (*Logger, error) <span class="cov8" title="1">{
        if logger == nil </span><span class="cov8" title="1">{
                return nil, errors.New("missing logger")
        }</span>
        <span class="cov8" title="1">return &amp;Logger{
                Logger: logger,
        }, nil</span>
}

// Errorf will output the error to the log
func (l *Logger) Errorf(format string, args ...interface{}) <span class="cov8" title="1">{
        l.Logger.Error(format, args...)
}</span>

// Infof will output the info to the log
func (l *Logger) Infof(format string, args ...interface{}) <span class="cov8" title="1">{
        l.Logger.Info(format, args...)
}</span>

// FailNow will panic
func (l *Logger) FailNow() <span class="cov8" title="1">{
        panic("testing.T failed, see logs for output (if any)")</span>
}

func (l *Logger) Log(i ...interface{}) <span class="cov8" title="1">{
        l.Logger.StandardLogger(&amp;hclog.StandardLoggerOptions{}).Println(i...)
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package gldap

import (
        "net"
        "os"
        "strings"
        "sync"
        "testing"

        ber "github.com/go-asn1-ber/asn1-ber"
        "github.com/go-ldap/ldap/v3"
        "github.com/stretchr/testify/require"
)

type testOptions struct {
        // test options
        withDescription string
}

func testDefaults() testOptions <span class="cov8" title="1">{
        return testOptions{}
}</span>

func getTestOpts(opt ...Option) testOptions <span class="cov8" title="1">{
        opts := testDefaults()
        applyOpts(&amp;opts, opt...)
        return opts
}</span>

// WithDescription allows you to specify an optional description.
func WithDescription(desc string) Option <span class="cov8" title="1">{
        return func(o interface{}) </span><span class="cov8" title="1">{
                if o, ok := o.(*testOptions); ok </span><span class="cov8" title="1">{
                        o.withDescription = desc
                }</span>
        }
}

func freePort(t *testing.T) int <span class="cov8" title="1">{
        t.Helper()
        require := require.New(t)
        addr, err := net.ResolveTCPAddr("tcp", "localhost:0")
        require.NoError(err)

        l, err := net.ListenTCP("tcp", addr)
        require.NoError(err)
        defer l.Close()
        return l.Addr().(*net.TCPAddr).Port
}</span>

func testStartTLSRequestPacket(t *testing.T, messageID int) *packet <span class="cov8" title="1">{
        t.Helper()
        envelope := testRequestEnvelope(t, int(messageID))

        request := ber.Encode(ber.ClassApplication, ber.TypeConstructed, ApplicationExtendedRequest, nil, "Start TLS")
        request.AppendChild(ber.NewString(ber.ClassContext, ber.TypePrimitive, 0, "1.3.6.1.4.1.1466.20037", "TLS Extended Command"))
        envelope.AppendChild(request)

        return &amp;packet{
                Packet: envelope,
        }
}</span>

func testSearchRequestPacket(t *testing.T, s SearchMessage) *packet <span class="cov8" title="1">{
        t.Helper()
        require := require.New(t)
        envelope := testRequestEnvelope(t, int(s.GetID()))
        pkt := ber.Encode(ber.ClassApplication, ber.TypeConstructed, ApplicationSearchRequest, nil, "Search Request")
        pkt.AppendChild(ber.NewString(ber.ClassUniversal, ber.TypePrimitive, ber.TagOctetString, s.BaseDN, "Base DN"))
        pkt.AppendChild(ber.NewInteger(ber.ClassUniversal, ber.TypePrimitive, ber.TagEnumerated, int64(s.Scope), "Scope"))
        pkt.AppendChild(ber.NewInteger(ber.ClassUniversal, ber.TypePrimitive, ber.TagEnumerated, int64(s.DerefAliases), "Deref Aliases"))
        pkt.AppendChild(ber.NewInteger(ber.ClassUniversal, ber.TypePrimitive, ber.TagInteger, int64(s.SizeLimit), "Size Limit"))
        pkt.AppendChild(ber.NewInteger(ber.ClassUniversal, ber.TypePrimitive, ber.TagInteger, int64(s.TimeLimit), "Time Limit"))
        pkt.AppendChild(ber.NewBoolean(ber.ClassUniversal, ber.TypePrimitive, ber.TagBoolean, s.TypesOnly, "Types Only"))

        // compile and encode filter
        filterPacket, err := ldap.CompileFilter(s.Filter)
        require.NoError(err)
        pkt.AppendChild(filterPacket)

        attributesPacket := ber.Encode(ber.ClassUniversal, ber.TypeConstructed, ber.TagSequence, nil, "Attributes")
        for _, attribute := range s.Attributes </span><span class="cov0" title="0">{
                attributesPacket.AppendChild(ber.NewString(ber.ClassUniversal, ber.TypePrimitive, ber.TagOctetString, attribute, "Attribute"))
        }</span>
        <span class="cov8" title="1">pkt.AppendChild(attributesPacket)

        envelope.AppendChild(pkt)
        if len(s.Controls) &gt; 0 </span><span class="cov0" title="0">{
                envelope.AppendChild(encodeControls(s.Controls))
        }</span>

        <span class="cov8" title="1">return &amp;packet{
                Packet: envelope,
        }</span>
}

func testSimpleBindRequestPacket(t *testing.T, m SimpleBindMessage) *packet <span class="cov8" title="1">{
        t.Helper()

        envelope := testRequestEnvelope(t, int(m.GetID()))
        pkt := ber.Encode(ber.ClassApplication, ber.TypeConstructed, ApplicationBindRequest, nil, "Bind Request")
        pkt.AppendChild(ber.NewInteger(ber.ClassUniversal, ber.TypePrimitive, ber.TagInteger, int64(3), "Version"))
        pkt.AppendChild(ber.NewString(ber.ClassUniversal, ber.TypePrimitive, ber.TagOctetString, m.UserName, "User Name"))
        pkt.AppendChild(ber.NewString(ber.ClassContext, ber.TypePrimitive, 0, string(m.Password), "Password"))
        envelope.AppendChild(pkt)

        if len(m.Controls) &gt; 0 </span><span class="cov8" title="1">{
                envelope.AppendChild(encodeControls(m.Controls))
        }</span>

        <span class="cov8" title="1">return &amp;packet{
                Packet: envelope,
        }</span>
}

func testUnbindRequestPacket(t *testing.T, m UnbindMessage) *packet <span class="cov8" title="1">{
        t.Helper()

        envelope := testRequestEnvelope(t, int(m.GetID()))
        pkt := ber.Encode(ber.ClassApplication, ber.TypeConstructed, ApplicationUnbindRequest, nil, "Unbind Request")
        envelope.AppendChild(pkt)

        return &amp;packet{
                Packet: envelope,
        }
}</span>

func testModifyRequestPacket(t *testing.T, m ModifyMessage) *packet <span class="cov8" title="1">{
        t.Helper()
        envelope := testRequestEnvelope(t, int(m.GetID()))
        pkt := ber.Encode(ber.ClassApplication, ber.TypeConstructed, ApplicationModifyRequest, nil, "Modify Request")
        pkt.AppendChild(ber.NewString(ber.ClassUniversal, ber.TypePrimitive, ber.TagOctetString, m.DN, "DN"))
        changes := ber.Encode(ber.ClassUniversal, ber.TypeConstructed, ber.TagSequence, nil, "Changes")
        for _, change := range m.Changes </span><span class="cov8" title="1">{
                changes.AppendChild(change.encode())
        }</span>
        <span class="cov8" title="1">pkt.AppendChild(changes)

        envelope.AppendChild(pkt)
        if len(m.Controls) &gt; 0 </span><span class="cov8" title="1">{
                envelope.AppendChild(encodeControls(m.Controls))
        }</span>
        <span class="cov8" title="1">return &amp;packet{
                Packet: envelope,
        }</span>
}

func testDeleteRequestPacket(t *testing.T, m DeleteMessage) *packet <span class="cov8" title="1">{
        t.Helper()
        envelope := testRequestEnvelope(t, int(m.GetID()))
        pkt := ber.Encode(ber.ClassApplication, ber.TypeConstructed, ApplicationDelRequest, nil, "Delete Request")
        pkt.Data.Write([]byte(m.DN))

        envelope.AppendChild(pkt)
        if len(m.Controls) &gt; 0 </span><span class="cov8" title="1">{
                envelope.AppendChild(encodeControls(m.Controls))
        }</span>
        <span class="cov8" title="1">return &amp;packet{
                Packet: envelope,
        }</span>
}

func testAddRequestPacket(t *testing.T, m AddMessage) *packet <span class="cov8" title="1">{
        t.Helper()
        envelope := testRequestEnvelope(t, int(m.GetID()))
        pkt := ber.Encode(ber.ClassApplication, ber.TypeConstructed, ApplicationAddRequest, nil, "Add Request")
        pkt.AppendChild(ber.NewString(ber.ClassUniversal, ber.TypePrimitive, ber.TagOctetString, m.DN, "DN"))
        attributes := ber.Encode(ber.ClassUniversal, ber.TypeConstructed, ber.TagSequence, nil, "Attributes")
        for _, attr := range m.Attributes </span><span class="cov8" title="1">{
                attributes.AppendChild(attr.encode())
        }</span>
        <span class="cov8" title="1">pkt.AppendChild(attributes)

        envelope.AppendChild(pkt)
        if len(m.Controls) &gt; 0 </span><span class="cov8" title="1">{
                envelope.AppendChild(encodeControls(m.Controls))
        }</span>
        <span class="cov8" title="1">return &amp;packet{
                Packet: envelope,
        }</span>
}

func testRequestEnvelope(t *testing.T, messageID int) *ber.Packet <span class="cov8" title="1">{
        p := ber.Encode(ber.ClassUniversal, ber.TypeConstructed, ber.TagSequence, nil, "LDAP Request")
        p.AppendChild(ber.NewInteger(ber.ClassUniversal, ber.TypePrimitive, ber.TagInteger, int64(messageID), "MessageID"))
        return p
}</span>

func testControlString(t *testing.T, controlType string, opt ...Option) *ControlString <span class="cov8" title="1">{
        t.Helper()
        require := require.New(t)
        c, err := NewControlString(controlType, opt...)
        require.NoError(err)
        return c
}</span>

func testControlManageDsaIT(t *testing.T, opt ...Option) *ControlManageDsaIT <span class="cov8" title="1">{
        t.Helper()
        require := require.New(t)
        c, err := NewControlManageDsaIT(opt...)
        require.NoError(err)
        return c
}</span>

func testControlMicrosoftNotification(t *testing.T, opt ...Option) *ControlMicrosoftNotification <span class="cov8" title="1">{
        t.Helper()
        require := require.New(t)
        c, err := NewControlMicrosoftNotification(opt...)
        require.NoError(err)
        return c
}</span>

func testControlMicrosoftServerLinkTTL(t *testing.T, opt ...Option) *ControlMicrosoftServerLinkTTL <span class="cov8" title="1">{
        t.Helper()
        require := require.New(t)
        c, err := NewControlMicrosoftServerLinkTTL(opt...)
        require.NoError(err)
        return c
}</span>

func testControlMicrosoftShowDeleted(t *testing.T, opt ...Option) *ControlMicrosoftShowDeleted <span class="cov8" title="1">{
        t.Helper()
        require := require.New(t)
        c, err := NewControlMicrosoftShowDeleted(opt...)
        require.NoError(err)
        return c
}</span>

func testControlPaging(t *testing.T, pagingSize uint32, opt ...Option) *ControlPaging <span class="cov8" title="1">{
        t.Helper()
        require := require.New(t)
        c, err := NewControlPaging(uint32(pagingSize), opt...)
        require.NoError(err)
        return c
}</span>

// TestWithDebug specifies that the test should be run under "debug" mode
func TestWithDebug(t *testing.T) bool <span class="cov8" title="1">{
        t.Helper()
        return strings.ToLower(os.Getenv("DEBUG")) == "true"
}</span>

func TestEncodeString(t *testing.T, tag ber.Tag, s string, opt ...Option) string <span class="cov8" title="1">{
        t.Helper()
        opts := getTestOpts(opt...)
        pkt := ber.NewString(ber.ClassUniversal, ber.TypePrimitive, tag, s, opts.withDescription)
        dec, err := ber.DecodePacketErr(pkt.Bytes())
        require.NoError(t, err)
        return string(dec.Bytes())
}</span>

type safeBuf struct {
        buf *strings.Builder
        mu  *sync.Mutex
}

func testSafeBuf(t *testing.T) *safeBuf <span class="cov8" title="1">{
        t.Helper()
        return &amp;safeBuf{
                mu:  &amp;sync.Mutex{},
                buf: &amp;strings.Builder{},
        }
}</span>
func (w *safeBuf) Write(p []byte) (n int, err error) <span class="cov8" title="1">{
        w.mu.Lock()
        defer w.mu.Unlock()
        return w.buf.Write(p)
}</span>

func (w *safeBuf) String() string <span class="cov0" title="0">{
        w.mu.Lock()
        defer w.mu.Unlock()
        return w.buf.String()
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
